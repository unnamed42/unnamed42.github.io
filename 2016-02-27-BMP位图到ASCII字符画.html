<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="renderer" content="webkit|ie-comp|ie-stand"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no"><title>BMP位图到ASCII字符画 - BUG研发中心</title><meta name="keywords" content=""><meta name="description" content="Warning: inexperienced programmer inside!"><meta name="author" content="Dr. A. Clef"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><link href="/css/style.css" rel="stylesheet" type="text/css"><link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"><script type="text/javascript">"jQuery"in window||(window._jqQ=[],window.jQuery=window.$=function(){_jqQ.push(arguments)});</script><script id="jquery-src" src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" async onload="_jqQ.forEach(function(n){$.apply($,n)}),delete window._jqQ"></script><script src="/js/script.js" type="text/javascript" async></script><script type="text/javascript">var CONFIG={disqus:{api_key:"1PwNiUJfZNlIZGUH0d0ZfKyOBXhdTclO1F9BJqRJDjcrJ5JVGe45C7YAQO0L5lFc",forum:"unnamed42-github"}};</script><script type="text/javascript">!function(){var t=document,e=t.createElement("script");e.type="text/javascript",e.async=!0,e.src="https://unnamed42-github.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}();</script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><script src="/js/disqus.js" type="text/javascript" defer></script><script type="text/x-mathjax-config">MathJax.Hub.Config({showProcessingMessages:!1,jax:["input/TeX","output/HTML-CSS","output/PreviewHTML"],extensions:["tex2jax.js","fast-preview.js","AssistiveMML.js"],TeX:{extensions:["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]},tex2jax:{inlineMath:[["$","$"]],displayMath:[["$$","$$"]],processEscapes:!0,skipTags:["script","noscript","style","textarea","pre","code"]},"HTML-CSS":{linebreaks:{automatic:!0}}});</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.2/MathJax.js?config=TeX-AMS_SVG" async></script><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script></head><body class="post"><nav id="header"><div class="container clearfix"><div class="logo" style="width:auto"><a href="/" title="BUG研发中心" rel="home" style="text-decoration:none"><span class="brand-logo">BUG研发中心</span></a></div><div id="global-nav"><div class="gnli"><a class="gna fa fa-home" href="/" title="BUG研发中心"><span class="gn-item">主页</span></a></div><div id="dropdown" class="gnli current"><a class="gna fa fa-bars" href="#"><span class="gn-item">导航</span></a><table id="dropdown-menu"><tbody><tr class="trline"><td class="tdleft">分类</td><td class="tdright tab-ul tab-categories"><a href="/categories/学习/">学习</a> <a href="/categories/杂项/">杂项</a> <a href="/categories/生活娱乐/">生活娱乐</a> <a href="/categories/编程/">编程</a></td></tr><tr><td class="tdleft">标签</td><td class="tdright tab-ul tab-tags"><a href="/tags/笑话/" style="font-size:12px">笑话</a> <a href="/tags/Hexo/" style="font-size:12px">Hexo</a> <a href="/tags/Markdown/" style="font-size:12px">Markdown</a> <a href="/tags/GitHub/" style="font-size:12px">GitHub</a> <a href="/tags/Leetcode/" style="font-size:12px">Leetcode</a> <a href="/tags/算法/" style="font-size:12px">算法</a> <a href="/tags/MathJax/" style="font-size:12px">MathJax</a> <a href="/tags/情感叙事/" style="font-size:12px">情感叙事</a> <a href="/tags/插件/" style="font-size:12px">插件</a> <a href="/tags/测试/" style="font-size:12px">测试</a> <a href="/tags/DnD/" style="font-size:12px">DnD</a> <a href="/tags/配置/" style="font-size:12px">配置</a> <a href="/tags/VPS/" style="font-size:12px">VPS</a></td></tr></tbody></table></div><div class="gnli"><a class="gna fa fa-archive" href="/archives/index.html"><span class="gn-item">归档</span></a></div><div class="gnli"><a class="gna fa fa-user" href="/about/index.html"><span class="gn-item">关于</span></a></div><div class="gnli"><a class="gna fa fa-rss" href="/atom.xml"><span class="gn-item">订阅</span></a></div></div><form id="search-form" action="/search.html"><input name="keywords" id="search-input" placeholder="输入关键词"> <button type="submit" id="search-submit"><span class="fa fa-search"></span></button></form></div></nav><main id="content"><div class="container clearfix"><div id="primary" class="has-toc"><nav class="breadcrumb-navigation"><a rel="bookmark" href="/">主页</a> <span class="breadcrumb-arrow fa fa-angle-right"></span> <a href="/categories/编程/" title="编程" rel="category tag">编程</a> <span class="breadcrumb-arrow fa fa-angle-right"></span> BMP位图到ASCII字符画</nav><article class="single-post"><header class="post-header"><h1 class="post-title"><a href="/2016-02-27-BMP位图到ASCII字符画.html" title="BMP位图到ASCII字符画">BMP位图到ASCII字符画</a></h1></header><div class="post-meta"><ul class="inline-ul"><li class="inline-li"><time>2016-02-27</time></li><li class="inline-li"><span class="post-span">·</span></li><li class="inline-li"><a href="/categories/编程/" title="编程" rel="category tag">编程</a></li><li class="inline-li"><span class="post-span">·</span></li><li class="inline-li"><span id="busuanzi_value_page_pv"></span> Views</li></ul></div><div class="post-body clearfix"><div class="post-content"><p>最近闲得蛋疼，所以诞生了搞些大新闻的念头。</p><p>由于我<ruby>不擅长<rp>(</rp><rt>lǎn de xué</rt><rp>)</rp></ruby>脚本语言，因此费力不讨好地去用C++来完成这项工作。</p><p>UPDATE 2016-03-18: 修复失效的图片链接</p><a id="more"></a><h2 id="bmp简略介绍">BMP简略介绍</h2><p>位图一共有两种类型，即：设备相关位图(DDB)和设备无关位图(DIB). DDB位图在早期的Windows系统（Windows 3.0以前）中是很普遍的，事实上它也是唯一的。然而，随着显示器制造技术的进步，以及显示设备的多样化，DDB位图的一些固有的问题开始浮现出来了。比如，它不能够存储（或者说获取）创建这张图片的原始设备的分辨率，这样，应用程序就不能快速的判断客户机的显示设备是否适合显示这张图片。为了解决这一难题，微软创建了DIB位图格式。</p><p>设备无关位图(Device-Independent Bitmap)包含下列的颜色和尺寸信息：</p><ul><li><p>原始设备（即创建图片的设备）的颜色格式</p></li><li><p>原始设备的分辨率</p></li><li><p>原始设备的调色板</p></li><li><p>一个位数组，由红、绿、蓝（RGB）三个值代表一个像素</p></li><li><p>一个数组压缩标志，用于表明数据的压缩方案（如果需要的话）</p></li></ul><h2 id="bmp文件结构">BMP文件结构</h2><p><img src="https://upload.wikimedia.org/wikipedia/commons/c/c4/BMPfileFormat.png" alt="Wikipedia: BMP文件结构图"></p><p><img src="https://msdn.microsoft.com/dynimg/IC444238.png" alt="MSDN: BMP文件结构简图"></p><p>位图文件由以下结构体依次构成：</p><table><thead><tr><th>结构体名称</th><th>可选</th><th>大小</th><th>用途</th><th>备注</th></tr></thead><tbody><tr><td>位图文件头</td><td>否</td><td>14字节</td><td>存储位图文件通用信息</td><td>仅在读取文件时有用</td></tr><tr><td>DIB头</td><td>否</td><td>固定（存在7种不同版本）</td><td>存储位图详细信息及像素格式</td><td>紧接在位图文件头后</td></tr><tr><td>附加位掩码</td><td>是</td><td>3或4 DWORD（12或16字节）</td><td>定义像素格式</td><td>仅在DIB头是BITMAPINFOHEADER时存在</td></tr><tr><td>调色板</td><td>见备注</td><td>可变</td><td>定义图像数据（像素数组）所用颜色</td><td>色深≤ 8时不能省略</td></tr><tr><td>填充区A</td><td>是</td><td>可变</td><td>结构体对齐</td><td>位图文件头中像素数组偏移量的产物</td></tr><tr><td>像素数组</td><td>否</td><td>可变</td><td>定义实际的像素数值</td><td>像素数据在DIB头和附加位掩码中定义。像素数组中每行均以4字节对齐</td></tr><tr><td>填充区B</td><td>是</td><td>可变</td><td>结构体对齐</td><td>DIB头中ICC色彩特性数据偏移量的产物</td></tr><tr><td>ICC色彩特性数据</td><td>是</td><td>可变</td><td>定义色彩特性</td><td>可以包含外部文件路径，由该文件来定义色彩特性</td></tr></tbody></table><h3 id="bitmapfileheader">BITMAPFILEHEADER</h3><p><code>BITMAPFILEHEADER</code>位于文件的开头，存储着整个文件的概要信息。<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dd183374.aspx" target="_blank" rel="noopener">MSDN</a>上，该结构体的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagBITMAPFILEHEADER</span> &#123;</span></span><br><span class="line">  WORD  bfType;</span><br><span class="line">  DWORD bfSize;</span><br><span class="line">  WORD  bfReserved1;</span><br><span class="line">  WORD  bfReserved2;</span><br><span class="line">  DWORD bfOffBits;</span><br><span class="line">&#125; BITMAPFILEHEADER, *PBITMAPFILEHEADER;</span><br></pre></td></tr></table></figure><p>注：<code>WORD</code>, <code>DWORD</code>为微软MFC的经典类型别名，类型的要求分别是16位无符号整型和32位无符号整型。</p><p>各变量作用如下：</p><ul><li><p><code>bfType</code>: 文件签名，标识文件类型。这两个字节内容是0x42 0x4D, 如果以<code>char</code>的方式来读取的话要求为<code>'B'</code>, <code>'M'</code>. 根据标准的不同，也可以是其他内容（见附表）。</p></li><li><p><code>bfSize</code>: 文件大小，记录整个文件的大小（单位：字节）。</p></li><li><p><code>bfReserved1</code>, <code>bfReserved2</code>: 保留位，其内容必须是0(MSDN); 取决于具体创建图形文件的程序(Wikipedia).</p></li><li><p><code>bfOffBits</code>: 偏移量（单位：字节），标识从<code>BITMAPFILEHEADER</code>结构体的开头到位图像素数据的偏移量。</p></li></ul><h4 id="bftype的可能值">bfType的可能值</h4><table><thead><tr><th style="text-align:center">值</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:center">BM</td><td>Windows 3.1x, 95, NT, … etc.</td></tr><tr><td style="text-align:center">BA</td><td>OS/2 struct Bitmap Array</td></tr><tr><td style="text-align:center">CI</td><td>OS/2 struct Color Icon</td></tr><tr><td style="text-align:center">CP</td><td>OS/2 const Color Pointer</td></tr><tr><td style="text-align:center">IC</td><td>OS/2 struct Icon</td></tr><tr><td style="text-align:center">PT</td><td>OS/2 Pointer</td></tr></tbody></table><h3 id="bitmapinfoheader">BITMAPINFOHEADER</h3><p>紧跟着<code>BITMAPFILEHEADER</code>的就是位图信息头，主要有<code>BITMAPINFOHEADER</code>, <code>BITMAPV4HEADER</code>, 以及<code>BITMAPV5HEADER</code>这几种。这里我们介绍使用最广的<code>BITMAPINFOHEADER</code>结构体。<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dd183376.aspx" target="_blank" rel="noopener">MSDN</a>上定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagBITMAPINFOHEADER</span> &#123;</span></span><br><span class="line">  DWORD biSize;</span><br><span class="line">  LONG  biWidth;</span><br><span class="line">  LONG  biHeight;</span><br><span class="line">  WORD  biPlanes;</span><br><span class="line">  WORD  biBitCount;</span><br><span class="line">  DWORD biCompression;</span><br><span class="line">  DWORD biSizeImage;</span><br><span class="line">  LONG  biXPelsPerMeter;</span><br><span class="line">  LONG  biYPelsPerMeter;</span><br><span class="line">  DWORD biClrUsed;</span><br><span class="line">  DWORD biClrImportant;</span><br><span class="line">&#125; BITMAPINFOHEADER, *PBITMAPINFOHEADER;</span><br></pre></td></tr></table></figure><p>注：<code>LONG</code>的要求为32位有符号整型。</p><p>各变量作用如下：</p><ul><li><p><code>biSize</code>: 该结构体需要的字节数。</p></li><li><p><code>biWidth</code>: 位图的宽度（单位：像素）。 如果<code>biCompression</code>为<code>BI_JPEG</code>或<code>BI_PNG</code>, 那么<code>biWidth</code>表示解压缩后图像的宽度。</p></li><li><p><code>biHeight</code>: 位图的高度（单位：像素）。 如果为正，位图像素就是从下往上，从左往右存储，原点在左下角。如果为负，则是从上至下存储。此时，<code>biCompression</code>必须为<code>BI_RGB</code>或<code>BI_BITFIELDS</code>. 从上至下存储的位图不能压缩。 如果<code>biCompression</code>为<code>BI_JPEG</code>或<code>BI_PNG</code>, 那么<code>biHeight</code>表示解压缩后图像的高度。</p></li><li><p><code>biPlanes</code>: 目标设备的颜色面板值数量。该值必须为1.</p></li><li><p><code>biBitCount</code>: 每像素的位(bit)数。即图像色深。该成员变量决定了位图的最大色彩数。该值必须为表格内容之一（表格附后）。</p></li><li><p><code>biCompression</code>: 表示从下至上存储的位图的压缩方式。具体值见下表（表格附后）。</p></li><li><p><code>biSizeImage</code>: 图像的大小（单位：字节），无压缩位图该值可能设为0. 如果<code>biCompression</code>为<code>BI_JPEG</code>或<code>BI_PNG</code>, 那么<code>biSizeImage</code>表示对应JPEG或PNG图像的缓冲区大小。</p></li><li><p><code>biXPelsPerMeter</code>: 目标设备位图的横向分辨率（单位：像素/米）。程序可根据该值来选择合适大小的位图来显示。</p></li><li><p><code>biYPelsPerMeter</code>: 目标设备位图的纵向分辨率（单位：像素/米）。</p></li><li><p><code>biClrUsed</code>: 表示该位图中使用过的颜色索引数量。如果该值为0, 那么位图使用的是<code>biCompression</code>压缩模式下对应<code>biBitCount</code>的最大色彩数。 如果该值非0且<code>biBitCount</code>小于16, 那么<code>biClrUsed</code>表示图像引擎或设备驱动访问的色彩数。如果<code>biBitCount</code>大于等于16, 那么<code>biClrUsed</code>表示颜色表大小来优化系统调色板的性能。如果<code>biBitCount</code>等于16或32, 优化过的调色板紧跟着接下来的3个<code>DWORD</code>掩码后开始。 如果位图阵列紧跟在<code>BITMAPINFO</code>后，那么它是填充位图(packed bitmap). 填充位图是由单个指针引用。填充位图要求该<code>biClrUsed</code>必须是0或颜色表的实际大小。</p></li><li><p><code>biClrImportant</code>: 为显示该位图所需要的颜色索引数量。如果该值为0, 那么所有颜色都是需要的。</p></li></ul><h4 id="bibitcount的可能值">biBitCount的可能值</h4><table><thead><tr><th style="text-align:center">值</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td>色深由内含的JPEG或PNG格式图像显式确定或隐含</td></tr><tr><td style="text-align:center">1</td><td>位图是单色图。<code>BITMAPINFO</code>的<code>bmiColors</code>包含两个条目。位图的每一bit表示一个像素，如果是0则像素颜色是<code>bmiColors</code>的第一个条目内容；其余情况是第二个条目内容</td></tr><tr><td style="text-align:center">4</td><td>位图色彩数量最大为16, <code>bmiColors</code>包含16个条目。每四bit表示一个像素</td></tr><tr><td style="text-align:center">8</td><td>位图色彩数量最大为256, <code>bmiColors</code>包含256个条目。每一字节表示一个像素</td></tr><tr><td style="text-align:center">16</td><td>位图色彩数量最大为$2^{16}$. 如果<code>biCompression</code>为<code>BI_RGB</code>, 那么<code>bmiColors</code>为<code>NULL</code>. 每一<code>WORD</code>表示一个像素</td></tr><tr><td style="text-align:center">24</td><td>位图色彩数量最大为$2^{24}$, 并且<code>bmiColors</code>为<code>NULL</code>. 每3字节表示一个像素，每一字节分别表示一个像素的BGR分量</td></tr><tr><td style="text-align:center">32</td><td>位图色彩数量最大为$2^{32}$. 如果<code>biCompression</code>为<code>BI_RGB</code>, 那么<code>bmiColors</code>为<code>NULL</code>. 每一<code>DWORD</code>表示一个像素</td></tr></tbody></table><h4 id="bicompression的可能值">biCompression的可能值</h4><table><thead><tr><th style="text-align:center">值</th><th style="text-align:center">标识</th><th>压缩方法</th><th>备注</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">BI_RGB</td><td>无</td><td>最常见</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">BI_RLE8</td><td>RLE8位/像素</td><td>只能用于格式为8位/像素的位图</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">BI_RLE4</td><td>RLE4位/像素</td><td>只能用于格式为4位/像素的位图</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">BI_BITFIELDS</td><td>位字段或者霍夫曼1D压缩（BITMAPCOREHEADER2）</td><td>像素格式由位掩码指定，或位图经过霍夫曼1D压缩（BITMAPCOREHEADER2）</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">BI_JPEG</td><td>JPEG或RLE-24压缩（BITMAPCOREHEADER2）</td><td>位图包含JPEG图像或经过RLE-24压缩（BITMAPCOREHEADER2）</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">BI_PNG</td><td>PNG</td><td>位图包含PNG图像</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">BI_ALPHABITFIELDS</td><td>位字段</td><td>针对WindowsCE.NET4.0及之后版本</td></tr></tbody></table><h3 id="bitmapinfo">BITMAPINFO</h3><p>该结构体包含了一个DIB的主要信息和色彩信息。<a href="https://msdn.microsoft.com/zh-cn/library/windows/desktop/dd183375.aspx" target="_blank" rel="noopener">MSDN</a>定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagBITMAPINFO</span> &#123;</span></span><br><span class="line">  BITMAPINFOHEADER bmiHeader;</span><br><span class="line">  RGBQUAD          bmiColors[<span class="number">1</span>];</span><br><span class="line">&#125; BITMAPINFO, *PBITMAPINFO;</span><br></pre></td></tr></table></figure><p>各变量作用如下：</p><ul><li><p><code>bmiHeader</code>: 见上一部分</p></li><li><p><code>bmiColors</code>: 一个<code>bmiColors</code>包含以下二者之一：</p><ul><li>一个<code>RGBQUAD</code>的数组，数组元素组成了颜色表。</li><li>一个16位无符号整型的数组，元素是本地调色板的颜色索引。</li></ul></li></ul><h4 id="rgbquad">RGBQUAD</h4><p>该结构体描述BGR色彩分量值。<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dd162938.aspx" target="_blank" rel="noopener">MSDN</a>定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagRGBQUAD</span> &#123;</span></span><br><span class="line">  BYTE rgbBlue;</span><br><span class="line">  BYTE rgbGreen;</span><br><span class="line">  BYTE rgbRed;</span><br><span class="line">  BYTE rgbReserved;</span><br><span class="line">&#125; RGBQUAD;</span><br></pre></td></tr></table></figure><p>注： <code>BYTE</code>的要求是宽为1字节的类型。一般为<code>typedef unsigned char BYTE;</code></p><p>需要注意的是它的真实顺序是BGR而不是RGB.</p><h2 id="读取bmp文件">读取BMP文件</h2><p>有了上面的资料我们就能很快地写出读取文件的代码。</p><p>首先准备好两个文件头结构体，注意要禁止编译器自动对齐。在GCC/Clang下可以用<code>__attribute__((packed))</code>, VS下可以用<code>#pragma pack(1)</code>.</p><figure class="highlight cpp"><figcaption><span>bmp.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __BMP__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __BMP__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_header</span>&#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> signature[<span class="number">2</span>];   <span class="comment">// 4 bytes signature, or you can use a single uint16_t instead.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> file_size;</span><br><span class="line">    <span class="keyword">uint16_t</span> reserved1;</span><br><span class="line">    <span class="keyword">uint16_t</span> reserved2;</span><br><span class="line">    <span class="keyword">uint32_t</span> off_bits;</span><br><span class="line">&#125; __attribute__((packed));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">info_header</span>&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> info_header_size;</span><br><span class="line">    <span class="keyword">int32_t</span> width;</span><br><span class="line">    <span class="keyword">int32_t</span> height;</span><br><span class="line">    <span class="keyword">uint16_t</span> planes;</span><br><span class="line">    <span class="keyword">uint16_t</span> bit_count;</span><br><span class="line">    <span class="keyword">uint32_t</span> compression;</span><br><span class="line">    <span class="keyword">uint32_t</span> image_size;</span><br><span class="line">    <span class="keyword">int32_t</span> x_res;</span><br><span class="line">    <span class="keyword">int32_t</span> y_res;</span><br><span class="line">    <span class="keyword">uint32_t</span> color_used;</span><br><span class="line">    <span class="keyword">uint32_t</span> color_important;</span><br><span class="line">&#125; __attribute__((packed));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename,file_header *f,info_header *i,<span class="keyword">uint8_t</span> *data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>然后可以写一个简单的读取程序。除第一个参数表示文件路径外，其它的均是以指针形式返回的返回值。</p><p>我们直接为每个像素分配3字节的空间来存储RGB信息，而非使用<code>RGBQUAD</code>结构体。为简单起见，假设我们读取的BMP文件都是24位真彩色的，无压缩，从下至上存储。</p><figure class="highlight cpp"><figcaption><span>bmp.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"bmp.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename,file_header *f,info_header *i,<span class="keyword">uint8_t</span>* &amp;data,<span class="keyword">uint32_t</span> &amp;size_of_data)</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">fstream <span class="title">file</span><span class="params">(filename,<span class="built_in">std</span>::ios::in|<span class="built_in">std</span>::ios::binary)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(!file.is_open()||!file.bad())</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"cannot open or read file"</span>);</span><br><span class="line">    file.read(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(f),<span class="keyword">sizeof</span>(file_header));</span><br><span class="line">    <span class="comment">// check signature of file</span></span><br><span class="line">    <span class="keyword">if</span>(f-&gt;signature[<span class="number">0</span>]!=<span class="string">'B'</span>||f-&gt;signature[<span class="number">1</span>]!=<span class="string">'M'</span>)&#123;</span><br><span class="line">        file.close();</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"Wrong image file type"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    file.read(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(i),<span class="keyword">sizeof</span>(info_header));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(i-&gt;bit_count&lt;<span class="number">8</span>)&#123;</span><br><span class="line">        file.close();</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"Unsupported format."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i-&gt;compression &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        file.close();</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"Unsupported compression mode."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// recalculate file size</span></span><br><span class="line">    file.seekg(<span class="number">0</span>,<span class="built_in">std</span>::ios::end);</span><br><span class="line">    f-&gt;file_size=file.tellg();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">uint32_t</span> data_size = i-&gt;width * i-&gt;height * i-&gt;bit_count / <span class="number">8</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">uint32_t</span> image_size=f-&gt;file_size - data_size;</span><br><span class="line">    data=<span class="keyword">new</span> <span class="keyword">uint8_t</span>[image_size];</span><br><span class="line">    size_of_data=image_size;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// set to the beginning</span></span><br><span class="line">    file.seekg(f-&gt;off_bits,<span class="built_in">std</span>::ios::beg);</span><br><span class="line">    <span class="comment">// read pixel data</span></span><br><span class="line">    file.read(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(data),image_size);</span><br><span class="line">    file.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="灰度转换">灰度转换</h2><p>现在我们得到了每个像素的RGB信息（上一步得到的<code>data</code>还需要经过处理变成RGB顺序），现在将其转换成灰度。我们使用这样的一个公式：</p><p>$$ Luminace = 0.299 Red + 0.587 Green + 0.114 Blue $$</p><ruby>最简单<rp>(</rp><rt>bù dòng nǎo</rt><rp>)</rp></ruby>的一个写法如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i=<span class="number">0U</span>;i&lt;size;i+=<span class="number">3</span>)</span><br><span class="line">    output[i]=<span class="keyword">uint8_t</span>(<span class="number">0.299</span>*data[i] + <span class="number">0.587</span>*data[i+<span class="number">1</span>] + <span class="number">0.114</span>*data[i+<span class="number">2</span>] + <span class="number">0.5</span>);</span><br></pre></td></tr></table></figure><p>最后加入<code>+ 0.5</code>是为了实现四舍五入而不是全部截断。</p><p>由于涉及到了浮点数，导致比整型之间的乘除法慢了很多。因此，我们把公式做个近似，变成了：</p><p>$$ Luminance = { {2 Red + 5 Green + Blue} \over 8} $$</p><p>在此基础上使用移位运算优化，整个变成了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i=<span class="number">0U</span>;i&lt;size;i+=<span class="number">3</span>)&#123;</span><br><span class="line">    <span class="keyword">auto</span> temp=data[i] &lt;&lt; <span class="number">1</span>;            <span class="comment">// 2*Red</span></span><br><span class="line">    temp+=(data[i+<span class="number">1</span>]&lt;&lt;<span class="number">2</span>) + data[i+<span class="number">1</span>];  <span class="comment">// 5*Green</span></span><br><span class="line">    temp+=data[i+<span class="number">2</span>];                   <span class="comment">// Blue</span></span><br><span class="line">    output[i]=<span class="keyword">uint8_t</span>(temp&gt;&gt;<span class="number">3</span>);        <span class="comment">// divide by 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="转换到ascii字符">转换到ASCII字符</h2><p>参考资料中给出了两种思路，在此只简单介绍其中一种。</p><p>该方法的基本思路是，针对每一个点（一些像素组成的小区域），计算它平均灰度强度然后将其替换为强度差不多的字符。基于此我们需要一组字符，记为<code>map</code>. 其强度我们可以采取线性分布，即满足：</p><p>$$ \begin{aligned} intensity(map_i) = intensity(map_{i-1})+Constant \end{aligned} $$</p><p>然后选取字符时可以像查表一样：</p><p>$$ character=map_{intensity(dot) \over Constant} $$</p><p>因此，大致步骤如下：</p><ol><li><p>将图片平均分割为像素点或者是（矩形）小区域</p></li><li><p>计算每个部分的灰度强度</p></li><li><p>将每个部分替换为与它灰度强度最相近的字符</p></li></ol><p>我们所选取的字符组最好是强度均匀分布。刚上手时可以使用<code>const char *map=&quot; .,:;ox%#@&quot;;</code>, 并按照强度递减排列处理。使用这个<code>map</code>的话，选取对应的字符的代码则是<code>char c=map[(255-intensity(dot))*strlen(map)/256];</code>.简略代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">ascii</span><span class="params">(<span class="keyword">uint8_t</span> *data,<span class="keyword">uint32_t</span> height,<span class="keyword">uint32_t</span> width,<span class="keyword">uint32_t</span> line_width,<span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">map</span>=<span class="string">"@#%xo;:,. "</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">result</span><span class="params">(<span class="string">""</span>)</span></span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> len=<span class="built_in">std</span>::<span class="built_in">strlen</span>(<span class="built_in">map</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> y=<span class="number">0U</span>;i&lt;height;++y)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x=<span class="number">0U</span>;x&lt;width;++x)&#123;</span><br><span class="line">            <span class="keyword">auto</span> intensity=data[y*line_width+x]+data[y*line_width+x+<span class="number">1</span>]+data[y*line_width+x+<span class="number">2</span>];</span><br><span class="line">            intensity=(intensity*len)/<span class="number">768</span>;      <span class="comment">// for average</span></span><br><span class="line">            result+=<span class="built_in">map</span>[len-intensity];</span><br><span class="line">        &#125;</span><br><span class="line">        result+=<span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换的效果可以看图：</p><p><img src="https://i.stack.imgur.com/V0zRq.png" alt="无耻的我从原作者处偷来的图"></p><h2 id="参考资料">参考资料</h2><ol><li><p><a href="http://www.songho.ca/dsp/luminance/luminance.html" target="_blank" rel="noopener">彩色图到灰度图</a></p></li><li><p><a href="http://stackoverflow.com/a/32987834" target="_blank" rel="noopener">灰度图到ASCII字符画</a></p></li><li><p><a href="https://en.wikipedia.org/wiki/BMP_file_format" target="_blank" rel="noopener">Wikipedia: BMP文件格式</a></p></li><li><p><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dd183391.aspx" target="_blank" rel="noopener">MSDN: BMP文件格式</a></p></li><li><p><a href="https://msdn.microsoft.com/library/windows/desktop/aa383751" target="_blank" rel="noopener">Windows Data Types</a></p></li></ol></div></div><div class="license-notice"><span>作者:</span>Dr. A. Clef<br><span>发布日期:</span>2016-02-27<br><span>修改日期:</span>2017-06-10<br><span>发布协议:</span> <a href="https://creativecommons.org/licenses/by-sa/4.0" target="_blank">BY-SA</a></div><nav class="post-tags"><a href="/tags/算法/" title="算法" rel="tag" class="fa fa-tag">算法</a></nav></article></div><ul id="pager"><li class="previous"><a href="/2016-06-22-2016-06-022-二叉树的遍历-无栈.html" title="二叉树的遍历-无栈" class="tooltipped tooltipped-n" aria-label="二叉树的遍历-无栈"><span class="fa fa-chevron-left"></span> 上一篇文章</a></li><li class="next"><a href="/2016-02-08-Leetcode-136-137-260-Single-Number-s.html" title="Leetcode 136, 137, 260 &#34;Single Number&#34;-s" class="tooltipped tooltipped-n" aria-label="Leetcode 136, 137, 260 &#34;Single Number&#34;-s">下一篇文章 <span class="fa fa-chevron-right"></span></a></li></ul><section id="comments"><div id="disqus_thread" class="disqus-thread"></div></section><nav id="toc" class="sticky"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#bmp简略介绍"><span class="toc-text">BMP简略介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bmp文件结构"><span class="toc-text">BMP文件结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#bitmapfileheader"><span class="toc-text">BITMAPFILEHEADER</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#bftype的可能值"><span class="toc-text">bfType的可能值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bitmapinfoheader"><span class="toc-text">BITMAPINFOHEADER</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#bibitcount的可能值"><span class="toc-text">biBitCount的可能值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bicompression的可能值"><span class="toc-text">biCompression的可能值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bitmapinfo"><span class="toc-text">BITMAPINFO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#rgbquad"><span class="toc-text">RGBQUAD</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#读取bmp文件"><span class="toc-text">读取BMP文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#灰度转换"><span class="toc-text">灰度转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#转换到ascii字符"><span class="toc-text">转换到ASCII字符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-text">参考资料</span></a></li></ol></nav></div></main><footer id="footer"><div class="container"><p><span class="cc-license"><a href="https://creativecommons.org/licenses/by-sa/4.0" target="_blank" title="Creative Commons license by-sa"><span class="cc cc-cc"></span> <span class="cc cc-by"></span> <span class="cc cc-sa"></span></a></span> &nbsp;2015-2018 BUG研发中心.</p><p>Themed by <a href="https://github.com/unnamed42/hexo-theme-kunkka">Kunkka</a> | Powered by <a href="https://hexo.io/">Hexo</a>.</p><div class="sns-icons"><span class="sns-icon fa-stack"><a target="_blank" href="https://github.com/unnamed42"><span class="fa fa-square fa-stack-2x"></span> <span class="fa fa-github fa-stack-1x fa-inverse"></span></a></span> <span class="sns-icon fa-stack"><a target="_blank" href="https://plus.google.com/u/0/101538012089625781458"><span class="fa fa-square fa-stack-2x"></span> <span class="fa fa-google-plus fa-stack-1x fa-inverse"></span></a></span> <span class="sns-icon fa-stack"><a target="_blank" href="https://www.zhihu.com/people/huang-wen-rui-74"><span class="fa fa-square fa-stack-2x"></span> <span class="fa fa-stack-1x fa-inverse">知</span></a></span> <span class="sns-icon fa-stack"><a target="_blank" href="http://tieba.baidu.com/home/main/?un=Xelnagaman"><span class="fa fa-square fa-stack-2x"></span> <span class="fa fa-stack-1x fa-inverse">贴</span></a></span></div></div></footer><div id="totop" title="送你上天"><canvas id="totop-canvas" width="48" height="48"></canvas><div id="totop-percent"></div></div></body></html>