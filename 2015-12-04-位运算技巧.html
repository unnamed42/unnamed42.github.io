<!DOCTYPE html><html lang=zh-CN><!-- Head tag --><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=renderer content=webkit|ie-comp|ie-stand><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no"><title>位运算技巧 - BUG研发中心</title><meta name=keywords content=""><meta name=description content="Warning: inexperienced programmer inside!"><meta name=author content="Dr. A. Clef"><link rel=alternate type=application/atom+xml href=/atom.xml><link href=/css/style.css rel=stylesheet type=text/css><link href=https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css rel=stylesheet type=text/css><script type=text/javascript>"jQuery"in window||(window._jqQ=[],window.jQuery=window.$=function(){_jqQ.push(arguments)});</script><script id=jquery-src src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js async onload="_jqQ.forEach(function(n){$.apply($,n)}),delete window._jqQ"></script><script src=/js/script.js type=text/javascript async></script><!-- Global javascript config object --><script type=text/javascript>var CONFIG={disqus:{api_key:"1PwNiUJfZNlIZGUH0d0ZfKyOBXhdTclO1F9BJqRJDjcrJ5JVGe45C7YAQO0L5lFc",forum:"unnamed42-github"}};</script><script type=text/javascript>!function(){var t=document,e=t.createElement("script");e.type="text/javascript",e.async=!0,e.src="https://unnamed42-github.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}();</script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><script src=/js/disqus.js type=text/javascript defer=defer></script><script type=text/x-mathjax-config>MathJax.Hub.Config({showProcessingMessages:!1,jax:["input/TeX","output/HTML-CSS","output/PreviewHTML"],extensions:["tex2jax.js","fast-preview.js","AssistiveMML.js"],TeX:{extensions:["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]},tex2jax:{inlineMath:[["$","$"]],displayMath:[["$$","$$"]],processEscapes:!0,skipTags:["script","noscript","style","textarea","pre","code"]},"HTML-CSS":{linebreaks:{automatic:!0}}});</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.2/MathJax.js?config=TeX-AMS_SVG" async></script><script src=https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js async></script></head><body class=post><nav id=header><div class="container clearfix"><div class=logo style=width:auto><a href="/" title=BUG研发中心 rel=home style=text-decoration:none><span class=brand-logo>BUG研发中心</span></a></div><div id=global-nav><ul class=gnul><li class=gnli><a class="gna fa fa-home" href="/" title=BUG研发中心><span class=gn-item>主页</span></a></li><li class="gnli dropdown current"><a class="gna fa fa-bars" href=#><span class=gn-item>导航</span></a><div class=submenu><div class=tab-content><table><tbody><tr class=trline><td class=tdleft>分类</td><td class=tdright><ul class=tab-categories><li class=cat-item><a href="/categories/学习/">学习</a></li><li class=cat-item><a href="/categories/杂项/">杂项</a></li><li class=cat-item><a href="/categories/生活娱乐/">生活娱乐</a></li><li class=cat-item><a href="/categories/编程/">编程</a></li></ul></td></tr><tr><td class=tdleft>标签</td><td class=tdright><div class=tab-tags><a href="/tags/笑话/" style=font-size:12px>笑话</a> <a href="/tags/Markdown/" style=font-size:12px>Markdown</a> <a href="/tags/Hexo/" style=font-size:12px>Hexo</a> <a href="/tags/MathJax/" style=font-size:12px>MathJax</a> <a href="/tags/Leetcode/" style=font-size:12px>Leetcode</a> <a href="/tags/算法/" style=font-size:12px>算法</a> <a href="/tags/GitHub/" style=font-size:12px>GitHub</a> <a href="/tags/情感叙事/" style=font-size:12px>情感叙事</a> <a href="/tags/配置/" style=font-size:12px>配置</a> <a href="/tags/插件/" style=font-size:12px>插件</a> <a href="/tags/测试/" style=font-size:12px>测试</a> <a href="/tags/DnD/" style=font-size:12px>DnD</a></div></td></tr></tbody></table></div></div></li><li class=gnli><a class="gna fa fa-archive" href=/archives/index.html><span class=gn-item>归档</span></a></li><li class=gnli><a class="gna fa fa-user" href=/about/index.html><span class=gn-item>关于</span></a></li><li class=gnli><a class="gna fa fa-rss" href=/atom.xml><span class=gn-item>订阅</span></a></li></ul></div><form id=search-form action=/search.html><input name=keywords id=search-input placeholder=输入关键词> <button type=submit id=search-submit><span class="fa fa-search"></span></button></form></div></nav><main id=content><div class="container clearfix"><div id=primary class=has-toc><nav class=breadcrumb-navigation><a rel=bookmark href="/">主页</a> <span class="breadcrumb-arrow fa fa-angle-right"></span> <a href="/categories/编程/" title=编程 rel="category tag">编程</a> <span class="breadcrumb-arrow fa fa-angle-right"></span> 位运算技巧</nav><article class=single-post><header class=post-header><h1 class=post-title><a href=/2015-12-04-位运算技巧.html title=位运算技巧>位运算技巧</a></h1></header><div class=post-meta><ul class=inline-ul><li class=inline-li><time>2015-12-04</time></li><li class=inline-li><span class=post-span>·</span></li><li class=inline-li><a href="/categories/编程/" title=编程 rel="category tag">编程</a></li><li class=inline-li><span class=post-span>·</span></li><li class=inline-li><span id=busuanzi_value_page_pv></span> Views</li></ul></div><div class="post-body clearfix"><div class=post-content><p><strong>深坑待填！</strong></p><p>本文翻译自<a href=https://graphics.stanford.edu/~seander/bithacks.html target=_blank rel=noopener>这篇文章</a>，原作者Sean Eron Anderson. 如果有翻译错误的地方，欢迎指正。另外，由于年代久远，文中给出的链接可能已经失效。</p><p>UPDATE 2016/09/30: 继续翻译，并改进已翻译文本</p><a id=more></a><h2 id=开头语>开头语</h2><p>本文所有代码片段皆属公有（除非特别指明）——您想怎么用就怎么用。所有的文本皆属Sean Eron Anderson版权所有（1997-2005）。本着希望帮助他人的想法，我将代码及其解释公之于众，但若要这些代码用于特定目的，请记住我并未明显或隐含地保证其可用和适用性。截止于2005年五月5日，所有代码均经过了完整的测试，并经上千人阅览。此外，卡内基·梅隆大学计算机学院院长<a href="http://www-2.cs.cmu.edu/~bryant/" target=_blank rel=noopener>Randal Bryant教授</a>使用他的轮子<a href="http://www-2.cs.cmu.edu/~uclid/" target=_blank rel=noopener>uclid代码测试系统</a>进行了测试，测试内容几乎涵盖了所有方面。他没有覆盖到的情况，我已经在32位机器上针对所有可能输入补充测试了一遍。<strong>对于第一个找到我代码里正当bug的人，我将给予他10美元的奖金（通过支票或PayPal）。如果将这笔钱转交慈善机构的话，增至20美元。</strong></p><h2 id=关于操作统计的说明>关于操作统计的说明</h2><p>统计本文算法中操作数量的时候，所有C语言运算符皆看做是一次操作。不涉及写入内存的中间过程，不在统计范围内。当然，这种统计方式只能是对真实的机器指令和CPU时间的一个近似。在此假定所有的操作耗费相同的时间。这虽然与真实情况不符，但的确是CPU发展努力的方向。一个代码样本在不同系统上运行时间会有很多细微的差别，可能是缓存大小、内存带宽、指令集等等因素造成的。总之，拿去跑一跑是确定方法之间快慢的最好方法，所以在实际机器上测试的时候，我所说的仅供参考。</p><h2 id=获取一个整数的正负号>获取一个整数的正负号</h2><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>int</span> v;        <span class=comment>//我们想知道v的符号</span></span><br><span class=line><span class=keyword>int</span> sign;     <span class=comment>//用来存放结果</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre></td><td class=code><pre><span class=line><span class=comment>// CHAR_BIT 代表一字节(byte)是多少位(bit)（一般是8）</span></span><br><span class=line>sign = -(v &lt; <span class=number>0</span>);  <span class=comment>//如果v&lt;0，得到-1，否则是0</span></span><br><span class=line><span class=comment>// 或者，为了避免在用标记寄存器的CPU (IA32) 上使用转移指令：</span></span><br><span class=line>sign = -(<span class=keyword>int</span>)((<span class=keyword>unsigned</span> <span class=keyword>int</span>)((<span class=keyword>int</span>)v) &gt;&gt; (<span class=keyword>sizeof</span>(<span class=keyword>int</span>) * CHAR_BIT - <span class=number>1</span>));</span><br><span class=line><span class=comment>// 或者，这样可以少一个机器指令（但牺牲了可移植性）：</span></span><br><span class=line>sign = v &gt;&gt; (<span class=keyword>sizeof</span>(<span class=keyword>int</span>) * CHAR_BIT - <span class=number>1</span>);</span><br></pre></td></tr></table></figure><p>最后一个表达式，对于32位整数求得<code>sign = v &gt;&gt; 31</code>，这比直接求法<code>sign = -(v &lt; 0)</code>少了一个操作。该方法之所以可行，是因为当我们把有符号整数向右移位时，最左边一位的值被复制到了其他位上。对一个有符号整数来说，最左边一位是1表示是负数，其他情况是0；所有位上全是1代表<code>-1</code>. 可惜的是，上述行为是与架构相关的。（译注：带符号数负数的左移在C99标准中属于未定义行为）</p><p>另外，如果你希望<code>sign</code>的结果是<code>1</code>或<code>-1</code>的话：</p><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line>sign = +<span class=number>1</span> | (v &gt;&gt; (<span class=keyword>sizeof</span>(<span class=keyword>int</span>) * CHAR_BIT - <span class=number>1</span>));  <span class=comment>// v &lt; 0得到 -1, 其余情况是 +1</span></span><br></pre></td></tr></table></figure><p>其次，你希望结果是<code>-1</code>, <code>0</code>或<code>1</code>的话：</p><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre></td><td class=code><pre><span class=line>sign = (v != <span class=number>0</span>) | -(<span class=keyword>int</span>)((<span class=keyword>unsigned</span> <span class=keyword>int</span>)((<span class=keyword>int</span>)v) &gt;&gt; (<span class=keyword>sizeof</span>(<span class=keyword>int</span>) * CHAR_BIT - <span class=number>1</span>));</span><br><span class=line><span class=comment>// 或者使用速度更快但移植性差的：</span></span><br><span class=line>sign = (v != <span class=number>0</span>) | (v &gt;&gt; (<span class=keyword>sizeof</span>(<span class=keyword>int</span>) * CHAR_BIT - <span class=number>1</span>));  <span class=comment>// -1, 0, or +1</span></span><br><span class=line><span class=comment>// 或者使用可移植的，简洁的，（也许）更快的：</span></span><br><span class=line>sign = (v &gt; <span class=number>0</span>) - (v &lt; <span class=number>0</span>); <span class=comment>// -1, 0, or +1</span></span><br></pre></td></tr></table></figure><p>此外，如果你想知道一个数是不是非负的，返回结果是<code>+1</code>或者<code>0</code>, 使用：</p><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line>sign = <span class=number>1</span> ^ ((<span class=keyword>unsigned</span> <span class=keyword>int</span>)v &gt;&gt; (<span class=keyword>sizeof</span>(<span class=keyword>int</span>) * CHAR_BIT - <span class=number>1</span>)); <span class=comment>// v &lt; 0得到0, 其余是1</span></span><br></pre></td></tr></table></figure><p>作者注：</p><ul><li>2003年3月7日，Angus Duggan指出1989 ANSI C标准规定有符号整型的右移运算结果取决于具体实现，因此在某些系统上靠右移的方法可能失效。</li><li>为了使代码可移植性更好，2005年9月28日，Toby Speight建议我使用 CHAR_BIT 而不是指定一个字节8位长。2006年3月4日，Angus推荐了上面的使用了类型转换的方法，它可移植性更好。</li><li>2009年9月12日，Rohit Garg给出了检测非负数的方法。</li></ul><h2 id=检测两个整数是否异号>检测两个整数是否异号</h2><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>int</span> x, y;               <span class=comment>// 待检测的两个数</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>bool</span> f = ((x ^ y) &lt; <span class=number>0</span>); <span class=comment>// 当且仅当x与y符号相反的时候为真</span></span><br></pre></td></tr></table></figure><p>作者注：</p><ul><li>2009年11月26日的时候Manfred Weis建议我加上这个条目。</li></ul><h2 id=不利用分支来计算整数的绝对值>不利用分支来计算整数的绝对值</h2><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>int</span> v;           <span class=comment>// 我们现在要求v的绝对值</span></span><br><span class=line><span class=keyword>unsigned</span> <span class=keyword>int</span> r;  <span class=comment>// 输出结果</span></span><br><span class=line><span class=keyword>int</span> <span class=keyword>const</span> mask = v &gt;&gt; <span class=keyword>sizeof</span>(<span class=keyword>int</span>) * CHAR_BIT - <span class=number>1</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line>r = (v + mask) ^ mask;</span><br></pre></td></tr></table></figure><p>另一个专利所有的变体：</p><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line>r = (v ^ mask) - mask;</span><br></pre></td></tr></table></figure><p>某些CPU没有绝对值指令（或者编译器未能使用到它）。在分支指令开销很大的机器上，上面的表达式能够比直接求法<code>r = (v &lt; 0) ? -(unsigned)v : v</code>快很多，尽管操作的数量一样。</p><p>作者注：</p><ul><li>2003年3月7日，Angus Duggan指出1989 ANSI C标准规定有符号整型的右移运算结果取决于具体实现，因此在某些系统上靠右移的方法可能失效。我拜读了ANSI C, 其中并没有要求将数值表示为补码，所以说这也可能是方法失效的原因（在那些逐渐退出历史舞台的老爷机上仍然采用反码表示）。</li><li>2004年3月14日，Keith H. Duggar告诉了我上面的变体，比我刚开始想出来的那个<code>r=(+1|(v&gt;&gt;(sizeof(int)*CHAR_BIT-1)))*v</code>要好，因为少用了个乘法。不幸的是，那个方法于2000年6月6日由Vladimir Yu Volkonsky在美国申请了专利，归属于Sun Microsystems.</li><li>2006年8月13日，Yuriy Kaminskiy告诉我专利可能失效因为在专利申请之前它就已经被发布出去了，比如早在1996年11月9日Agner Fog就已经发表的<a href=http://www.goof.com/pcg/doc/pentopt.txt target=_blank rel=noopener>How to Optimize for the Pentium Processor</a>. Yuriy还告诉我那篇文档在1997年翻译成了俄文，而Vladimir可能读过。此外，互联网档案也有个指向它的<a href=http://web.archive.org/web/19961201174141/www.x86.org/ftp/articles/pentopt/PENTOPT.TXT target=_blank rel=noopener>旧链接</a>。</li><li>2007年1月30日，Peter Kankowski对我分享了他受Microsoft Visual C++编译器输出启发而想到的<a href="http://smallcode.weblogs.us/2007/01/31/microsoft-probably-uses-the-abs-function-patented-by-sun/" target=_blank rel=noopener>绝对值版本</a>。该方法被拿来作为本题的主要解决方案。</li><li>2007年12月6日，Hai Jin抱怨说结果是有符号的，所以计算大多数负数绝对值的时候结果还是负的。</li><li>2008年4月15日，Andrew Shapira指出那个直接求法可能会溢出，因为缺少一个<code>(unsigned)</code>的类型转换。为了尽可能满足移植性要求，他给我的改进求法是<code>(v &lt; 0) ? (1 + ((unsigned)(-1-v))) : (unsigned)v</code>.</li><li>2008年7月9日，Vincent Lefèvre引用ISO C99标准说服了我，让把上面那个删掉，因为即使不是使用补码的机器<code>-(unsigned)v</code>也能得到正确的结果。计算<code>-(unsigned)v</code>的时候，首先加上<code>2**N</code>来将负值<code>v</code>转化成无符号值，得到<code>v</code>的补码表示（记做<code>U</code>）。然后，取<code>U</code>的相反数，得到结果：<code>-U = 0 - U = 2**N - U = 2**N - (v + 2**N) = -v = abs(v)</code>.</li></ul><p>译注：2**N 表示 $2^N$.</p><h2 id=不利用分支来计算两个整数的最大-max-最小-min-值>不利用分支来计算两个整数的最大(max)最小(min)值</h2><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>int</span> x;</span><br><span class=line><span class=keyword>int</span> y;  <span class=comment>// 我们要计算x, y的最大最小值</span></span><br><span class=line><span class=keyword>int</span> r;  <span class=comment>// 存放结果</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line>r = y ^ ((x ^ y) &amp; -(x &lt; y)); <span class=comment>// min(x, y)</span></span><br></pre></td></tr></table></figure><p>这个世界上还有使用条件分支非常耗费时间的老爷机，而且没有条件移动指令。在这些机器上上面的方法可能会比直接求法<code>r = (x &lt; y) ? x : y</code>要快，尽管位运算解法涉及了两个以上的指令（虽然一般说来，直接解法是最好的）。 解法证明如下：如果<code>x &lt; y</code>, 那么<code>-(x &lt; y)</code>的各二进制位就全是1, 所以<code>r = y ^ ((x ^ y) &amp; -(x &lt; y)) = y ^ ((x ^ y) &amp; ~0 = y ^ x ^ y = x</code>. 另外，如果<code>x &gt;= y</code>, 那么<code>-(x &lt; y)</code>就全是0, 所以<code>r = y ^ ((x ^ y) &amp; 0) = y</code>. 在某些机器上，计算<code>(x &lt; y)</code>要得到0或1的话需要分支指令，因此该解法不具备任何优势。</p><p>求最大值的话，使用：</p><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line>r = x ^ ((x ^ y) &amp; -(x &lt; y)); <span class=comment>// max(x, y)</span></span><br></pre></td></tr></table></figure><h3 id=快而脏的解法>快而脏的解法</h3><p>如果你知道<code>INT_MIN &lt;= x - y &lt;= INT_MAX</code>的话，那你就可以用下面这种解法，由于它只需要计算一次<code>(x - y)</code>所以会快一点。</p><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre></td><td class=code><pre><span class=line>r = y + ((x - y) &amp; ((x - y) &gt;&gt; (<span class=keyword>sizeof</span>(<span class=keyword>int</span>) * CHAR_BIT - <span class=number>1</span>))); <span class=comment>// min(x, y)</span></span><br><span class=line>r = x - ((x - y) &amp; ((x - y) &gt;&gt; (<span class=keyword>sizeof</span>(<span class=keyword>int</span>) * CHAR_BIT - <span class=number>1</span>))); <span class=comment>// max(x, y)</span></span><br></pre></td></tr></table></figure><p>由于1989 ANSI C未规定有符号数右移的结果，所以该解法不可移植。如果溢出时抛出异常，那么减法时<code>x</code>与<code>y</code>的值就是无符号型或者被转换成无符号型来防止不必要的异常抛出。然而这里右移运算需要一个有符号的操作数，使得右移负数时填充1，所以这里转换成有符号整型。</p><p>作者注：</p><ul><li>2003年3月7日，Angus Duggan指出右移的可移植性问题。</li><li>2005年5月3日，Randal E. Bryant警告我说需要一个<code>INT_MIN &lt;= x - y &lt;= INT_MAX</code>的前提条件，并给出了一个慢而脏的修改版本。以上只在这个快而脏的解法里考虑了。</li><li>2005年7月6日，Nigel Horspoon观察到在奔腾上，由于gcc对<code>(x &lt; y)</code>的求值问题，它生成了和直接解法一样的代码。</li><li>2008年7月9日，Vincent Lefèvre指出<code>r = y + ((x - y) &amp; -(x &lt; y))</code>里的减法有潜在的溢出风险(这是我前一版的代码)。</li><li>2009年6月2日，Timothy B. Terriberry建议我使用异或而不是加减来避免溢出的危险。</li></ul><h2 id=检测一个数是不是2的次幂>检测一个数是不是2的次幂</h2><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>unsigned</span> <span class=keyword>int</span> v; <span class=comment>// 要检测的数是v</span></span><br><span class=line><span class=keyword>bool</span> f;         <span class=comment>// 存放结果</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line>f = (v &amp; (v - <span class=number>1</span>)) == <span class=number>0</span>;</span><br></pre></td></tr></table></figure><p>注意<code>0</code>并不是2的多少次幂，因此做如下修改：</p><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line>f = v &amp;&amp; !(v &amp; (v - <span class=number>1</span>));</span><br></pre></td></tr></table></figure><h2 id=符号扩展>符号扩展</h2><h3 id=从给定位宽扩展>从给定位宽扩展</h3><p>符号扩展对于内建类型来说是自动的，比如从<code>char</code>到<code>int</code>. 但是，假设你有一个以<code>b</code>位补码表示的有符号整数<code>x</code>, 你想把<code>x</code>转换成<code>int</code>型的，此时存储空间大于<code>b</code>位。只是简单地复制的话，当<code>x</code>是正数的时候还可以，是负数的时候就不对了，必须进行符号扩展。例如，假设我们只用4位来存储数字，那么<code>-3</code>表示成二进制就是<code>1101</code>. 如果用8位来存，那么就是<code>11111101</code>. 当扩展一个负数的时候需要将扩展的高位全赋为1， 这就是符号扩展。在C语言里，符号扩展就是小事一桩，因为可以在<code>struct</code>或<code>union</code>里使用位域。例如，要将5位长整数扩展到<code>int</code>型：</p><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>int</span> x; <span class=comment>// 将它从5位长转换到int</span></span><br><span class=line><span class=keyword>int</span> r; <span class=comment>// 存放结果</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre></td><td class=code><pre><span class=line><span class=class><span class=keyword>struct</span> &#123;</span><span class=keyword>signed</span> <span class=keyword>int</span> x:<span class=number>5</span>;&#125; s;</span><br><span class=line>r = s.x = x;</span><br></pre></td></tr></table></figure><p>下面是一个使用了相同语言特性的C++模板函数，仅用一个操作，就能从b位长扩展（尽管编译器生成的肯定不止这么点）：</p><figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>template</span> &lt;<span class=keyword>typename</span> T, <span class=keyword>unsigned</span> B&gt;</span><br><span class=line><span class=function><span class=keyword>inline</span> T <span class=title>signextend</span><span class=params>(<span class=keyword>const</span> T x)</span></span></span><br><span class=line><span class=function></span>&#123;</span><br><span class=line>  <span class=class><span class=keyword>struct</span> &#123;</span>T x:B;&#125; s;</span><br><span class=line>  <span class=keyword>return</span> s.x = x;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=keyword>int</span> r = signextend&lt;<span class=keyword>signed</span> <span class=keyword>int</span>,<span class=number>5</span>&gt;(x);  <span class=comment>// 从5位长的x扩展到int型的r</span></span><br></pre></td></tr></table></figure><p>作者注：</p><ul><li>2005年5月2日，John Byrd发现了代码里一处拼写错误（都是HTML的锅）。</li><li>2006年3月4日，Pat Wood指出ANSI C标准要求位域需要关键字<code>signed</code>来表示有符号数，否则其符号未定义。</li></ul><h3 id=从不定长位宽扩展>从不定长位宽扩展</h3><p>有时我们需要扩展的数并不知道它的位长<code>b</code>. 或者我们用的是一门没有位域特性的语言，比如 Java.</p><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>unsigned</span> b; <span class=comment>// 表示x的位长</span></span><br><span class=line><span class=keyword>int</span> x;      <span class=comment>// 扩展这个b位长的数x</span></span><br><span class=line><span class=keyword>int</span> r;      <span class=comment>// 存放结果</span></span><br><span class=line><span class=keyword>int</span> <span class=keyword>const</span> m = <span class=number>1U</span> &lt;&lt; (b - <span class=number>1</span>); <span class=comment>// 如果给出b的话，位掩码可以提前算出来</span></span><br><span class=line></span><br><span class=line>x = x &amp; ((<span class=number>1U</span> &lt;&lt; b) - <span class=number>1</span>);  <span class=comment>// 如果x的b位以上已经是0的话，跳过这一步</span></span><br><span class=line>r = (x ^ m) - m;</span><br></pre></td></tr></table></figure><p>上面的代码需要四次操作，但如果位宽给定的话，我们就只需要两个高效率的操作（假设高位已经全是0）。</p><p>一个牺牲了可移植性的稍快点的方法如下，这种方法并不要求<code>x</code>的<code>b</code>位以上的数字是0:</p><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>int</span> <span class=keyword>const</span> m = CHAR_BIT * <span class=keyword>sizeof</span>(x) - b;</span><br><span class=line>r = (x &lt;&lt; m) &gt;&gt; m;</span><br></pre></td></tr></table></figure><p>作者注：</p><ul><li>2004年6月13日，Sean A. Irvine希望我能在本页加上这些符号扩展的方法。他给了我最初的版本<code>m = (1 &lt;&lt; (b - 1)) - 1; r = -(x &amp; ~m) | x</code>, 后来被我优化成了<code>m = 1U &lt;&lt; (b - 1); r = -(x &amp; m) | x</code>.</li><li>然而2007年5月11日，Shay Green给了我上面解法里的版本，比我的还少一次操作。</li><li>2008年10月15日，Vipin Sharma给我改进建议，考虑到了<code>x</code>的高位可能有<code>1</code>的情况。</li><li>2009年12月31日，Chris Pirazzi, 建议我加上下面要讲的那种解法。</li></ul><h3 id=从不定长位宽扩展-3次操作>从不定长位宽扩展，3次操作</h3><p>下面讲的这个解法可能在某些机器上较慢，因为它需要乘除法。该版本需要4次操作。如果你知道位宽<code>b</code>比1大，请使用<code>r = (x * multipliers[b]) / multipliers[b]</code>完成这种类型的符号扩展，它仅需3次操作，一次查表。</p><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>unsigned</span> b; <span class=comment>// 表示x的位长</span></span><br><span class=line><span class=keyword>int</span> x;      <span class=comment>// 扩展这个b位长的数x</span></span><br><span class=line><span class=keyword>int</span> r;      <span class=comment>// 存放结果</span></span><br><span class=line></span><br><span class=line><span class=meta>#<span class=meta-keyword>define</span> M(B) (1U &lt;&lt; ((sizeof(x) * CHAR_BIT) - B)) <span class=comment>// CHAR_BIT=bits/byte</span></span></span><br><span class=line><span class=keyword>static</span> <span class=keyword>int</span> <span class=keyword>const</span> multipliers[] = </span><br><span class=line>&#123;</span><br><span class=line>  <span class=number>0</span>,     M(<span class=number>1</span>),  M(<span class=number>2</span>),  M(<span class=number>3</span>),  M(<span class=number>4</span>),  M(<span class=number>5</span>),  M(<span class=number>6</span>),  M(<span class=number>7</span>),</span><br><span class=line>  M(<span class=number>8</span>),  M(<span class=number>9</span>),  M(<span class=number>10</span>), M(<span class=number>11</span>), M(<span class=number>12</span>), M(<span class=number>13</span>), M(<span class=number>14</span>), M(<span class=number>15</span>),</span><br><span class=line>  M(<span class=number>16</span>), M(<span class=number>17</span>), M(<span class=number>18</span>), M(<span class=number>19</span>), M(<span class=number>20</span>), M(<span class=number>21</span>), M(<span class=number>22</span>), M(<span class=number>23</span>),</span><br><span class=line>  M(<span class=number>24</span>), M(<span class=number>25</span>), M(<span class=number>26</span>), M(<span class=number>27</span>), M(<span class=number>28</span>), M(<span class=number>29</span>), M(<span class=number>30</span>), M(<span class=number>31</span>),</span><br><span class=line>  M(<span class=number>32</span>)</span><br><span class=line>&#125;; <span class=comment>// (如果大于64位，继续添加)</span></span><br><span class=line><span class=keyword>static</span> <span class=keyword>int</span> <span class=keyword>const</span> divisors[] = </span><br><span class=line>&#123;</span><br><span class=line>  <span class=number>1</span>,    ~M(<span class=number>1</span>),  M(<span class=number>2</span>),  M(<span class=number>3</span>),  M(<span class=number>4</span>),  M(<span class=number>5</span>),  M(<span class=number>6</span>),  M(<span class=number>7</span>),</span><br><span class=line>  M(<span class=number>8</span>),  M(<span class=number>9</span>),  M(<span class=number>10</span>), M(<span class=number>11</span>), M(<span class=number>12</span>), M(<span class=number>13</span>), M(<span class=number>14</span>), M(<span class=number>15</span>),</span><br><span class=line>  M(<span class=number>16</span>), M(<span class=number>17</span>), M(<span class=number>18</span>), M(<span class=number>19</span>), M(<span class=number>20</span>), M(<span class=number>21</span>), M(<span class=number>22</span>), M(<span class=number>23</span>),</span><br><span class=line>  M(<span class=number>24</span>), M(<span class=number>25</span>), M(<span class=number>26</span>), M(<span class=number>27</span>), M(<span class=number>28</span>), M(<span class=number>29</span>), M(<span class=number>30</span>), M(<span class=number>31</span>),</span><br><span class=line>  M(<span class=number>32</span>)</span><br><span class=line>&#125;; <span class=comment>// (同上)</span></span><br><span class=line><span class=meta>#<span class=meta-keyword>undef</span> M</span></span><br><span class=line></span><br><span class=line>r = (x * multipliers[b]) / divisors[b];</span><br></pre></td></tr></table></figure><p>下面的这个变体并不可移植，但在使用算数右移的架构上，能保留符号，应该能快一点。</p><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>const</span> <span class=keyword>int</span> s = -b; <span class=comment>// 或者:  sizeof(x) * CHAR_BIT - b;</span></span><br><span class=line>r = (x &lt;&lt; s) &gt;&gt; s;</span><br></pre></td></tr></table></figure><p>作者注：</p><ul><li>2005年5月3日Randal E. Bryant发现了早期版本里的一个bug(把<code>multipliers[]</code>用作了<code>divisors[]</code>)，导致了当<code>x=1,b=1</code>的时候出错。</li></ul><h2 id=选择性地置位清零-不利用分支>选择性地置位清零，不利用分支</h2><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>bool</span> f;         <span class=comment>// 表示条件</span></span><br><span class=line><span class=keyword>unsigned</span> <span class=keyword>int</span> m; <span class=comment>// 位掩码</span></span><br><span class=line><span class=keyword>unsigned</span> <span class=keyword>int</span> w; <span class=comment>// 待修改的输入：if (f) w |= m; else w &amp;= ~m;</span></span><br><span class=line></span><br><span class=line>w ^= (-f ^ w) &amp; m;</span><br><span class=line></span><br><span class=line><span class=comment>// 或，针对超标量CPU架构：</span></span><br><span class=line>w = (w &amp; ~m) | (-f &amp; m);</span><br></pre></td></tr></table></figure><p>作者注：</p><ul><li>在某些架构上，没有条件分支要强于使用多两倍的操作数量来计算分支。例如，据非正式测试显示，在AMD Athlon™ XP 2100+上能快上5-10%. Intel Core 2 Duo运行超标量版比普通版快了约16%.</li><li>2003年12月11日，Glenn Slayden告诉了我第一个版本。</li><li>2007年4月3日，Marco Yu告诉了我超标量版并于两天后指出了两个拼写错误。</li></ul><h2 id=选择性地取负-不利用分支>选择性地取负，不利用分支</h2><p>如果你希望仅当条件为假的时候取负，下面是不涉及条件分支的版本：</p><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>bool</span> fDontNegate;  <span class=comment>// 标识我们什么时候不对v取反</span></span><br><span class=line><span class=keyword>int</span> v;             <span class=comment>// 待操作的数v</span></span><br><span class=line><span class=keyword>int</span> r;             <span class=comment>// result = fDontNegate ? v : -v;</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line>r = (fDontNegate ^ (fDontNegate - <span class=number>1</span>)) * v;</span><br></pre></td></tr></table></figure><p>如果你希望当条件为真时操作：</p><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>bool</span> fNegate;  <span class=comment>// 标识我们什么时候对v取反</span></span><br><span class=line><span class=keyword>int</span> v;         <span class=comment>// 待操作的数v</span></span><br><span class=line><span class=keyword>int</span> r;         <span class=comment>// result = fNegate ? -v : v;</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line>r = (v ^ -fNegate) + fNegate;</span><br></pre></td></tr></table></figure><p>作者注：</p><ul><li>2009年6月2日，Avraham Plotnitzky建议我加上第一个版本。</li><li>我又想避免使用乘法，因此在2009年6月8日想出了第二个版本。</li><li>2009年11月26日，Alfonso De Gregorio指出我丢了几个括号，并收到了bug奖励。</li></ul><h2 id=根据掩码合并两个数>根据掩码合并两个数</h2><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>unsigned</span> <span class=keyword>int</span> a;    <span class=comment>// 合并未屏蔽位</span></span><br><span class=line><span class=keyword>unsigned</span> <span class=keyword>int</span> b;    <span class=comment>// 合并屏蔽位</span></span><br><span class=line><span class=keyword>unsigned</span> <span class=keyword>int</span> mask; <span class=comment>// 1表示要合并b的对应位; 0针对a.</span></span><br><span class=line><span class=keyword>unsigned</span> <span class=keyword>int</span> r;    <span class=comment>// (a &amp; ~mask) | (b &amp; mask) 的结果</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line>r = a ^ ((a ^ b) &amp; mask);</span><br></pre></td></tr></table></figure><p>相比合并两个数的直接解法，我的比它少了一个操作。如果掩码是常量的话，这种方法不占任何优势。</p><p>作者注：</p><ul><li>2006年2月9日，Ron Jeffery给了我这个。</li></ul><h2 id=统计数位中1的个数>统计数位中1的个数</h2><h3 id=简单粗暴的解法>简单粗暴的解法</h3><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>unsigned</span> <span class=keyword>int</span> v; <span class=comment>// 待统计的数</span></span><br><span class=line><span class=keyword>unsigned</span> <span class=keyword>int</span> c; <span class=comment>// 用来累加计数</span></span><br><span class=line></span><br><span class=line><span class=keyword>for</span> (c = <span class=number>0</span>; v; v &gt;&gt;= <span class=number>1</span>)</span><br><span class=line>&#123;</span><br><span class=line>  c += v &amp; <span class=number>1</span>;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><p>这种解法每一位一次循环，直到没有<code>1</code>. 所以对一个只有最高位是<code>1</code>的32位数来说，它会循环32次。</p><h3 id=查表法>查表法</h3><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>static</span> <span class=keyword>const</span> <span class=keyword>unsigned</span> <span class=keyword>char</span> BitsSetTable256[<span class=number>256</span>] = </span><br><span class=line>&#123;</span><br><span class=line>#   define B2(n) n,     n+<span class=number>1</span>,     n+<span class=number>1</span>,     n+<span class=number>2</span></span><br><span class=line>#   define B4(n) B2(n), B2(n+<span class=number>1</span>), B2(n+<span class=number>1</span>), B2(n+<span class=number>2</span>)</span><br><span class=line>#   define B6(n) B4(n), B4(n+<span class=number>1</span>), B4(n+<span class=number>1</span>), B4(n+<span class=number>2</span>)</span><br><span class=line>    B6(<span class=number>0</span>), B6(<span class=number>1</span>), B6(<span class=number>1</span>), B6(<span class=number>2</span>)</span><br><span class=line>&#125;;</span><br><span class=line></span><br><span class=line><span class=keyword>unsigned</span> <span class=keyword>int</span> v; <span class=comment>// 待统计的数</span></span><br><span class=line><span class=keyword>unsigned</span> <span class=keyword>int</span> c; <span class=comment>// 统计1的个数</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre></td><td class=code><pre><span class=line>c = BitsSetTable256[v &amp; <span class=number>0xff</span>] + </span><br><span class=line>    BitsSetTable256[(v &gt;&gt; <span class=number>8</span>) &amp; <span class=number>0xff</span>] + </span><br><span class=line>    BitsSetTable256[(v &gt;&gt; <span class=number>16</span>) &amp; <span class=number>0xff</span>] + </span><br><span class=line>    BitsSetTable256[v &gt;&gt; <span class=number>24</span>];</span><br></pre></td></tr></table></figure><p>或者:</p><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>unsigned</span> <span class=keyword>char</span> * p = (<span class=keyword>unsigned</span> <span class=keyword>char</span> *) &amp;v;</span><br><span class=line>c = BitsSetTable256[p[<span class=number>0</span>]] + </span><br><span class=line>    BitsSetTable256[p[<span class=number>1</span>]] + </span><br><span class=line>    BitsSetTable256[p[<span class=number>2</span>]] +</span><br><span class=line>    BitsSetTable256[p[<span class=number>3</span>]];</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre></td><td class=code><pre><span class=line><span class=comment>// 用算法来初始化数组</span></span><br><span class=line>BitsSetTable256[<span class=number>0</span>] = <span class=number>0</span>;</span><br><span class=line><span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i &lt; <span class=number>256</span>; i++)</span><br><span class=line>&#123;</span><br><span class=line>  BitsSetTable256[i] = (i &amp; <span class=number>1</span>) + BitsSetTable256[i / <span class=number>2</span>];</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><p>作者注：</p><ul><li>2009年7月14日Hallvard Furuseth建议我使用宏来生成表。</li></ul><h3 id=brian-kernighan的方法>Brian Kernighan的方法</h3><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>unsigned</span> <span class=keyword>int</span> v;</span><br><span class=line><span class=keyword>unsigned</span> <span class=keyword>int</span> c;</span><br><span class=line><span class=keyword>for</span> (c = <span class=number>0</span>; v; c++)</span><br><span class=line>&#123;</span><br><span class=line>  v &amp;= v - <span class=number>1</span>; <span class=comment>// 清除最低非0位</span></span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><p>这种方法的循环次数和<code>1</code>的个数一样多。所以如果有一个只有最高位是<code>1</code>的数，只会循环一次。</p><p>作者注：</p><ul><li>该方法发表于1988, <em>the C Programming Language 2nd Ed</em> (作者Brian W. Kernighan和Dennis M. Ritchie). 书中练习2-9提到了这种方法。</li><li>2006年4月19日，Don Knuth指出这种方法是由Peter Wegner在 <em>CACM 3</em> (1960), 322第一次发表。（同时也由Derrick Lehmer指出该方法在1964年Beckenbach编过的一本书里发表过。）</li></ul><h3 id=针对14-24-或32位长数字-使用64位指令集>针对14, 24, 或32位长数字，使用64位指令集</h3><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>unsigned</span> <span class=keyword>int</span> v;</span><br><span class=line><span class=keyword>unsigned</span> <span class=keyword>int</span> c;</span><br><span class=line></span><br><span class=line><span class=comment>// 针对至多14位长的v:</span></span><br><span class=line>c = (v * <span class=number>0x200040008001</span>ULL &amp; <span class=number>0x111111111111111</span>ULL) % <span class=number>0xf</span>;</span><br><span class=line></span><br><span class=line><span class=comment>// 针对至多24位长的v:</span></span><br><span class=line>c =  ((v &amp; <span class=number>0xfff</span>) * <span class=number>0x1001001001001</span>ULL &amp; <span class=number>0x84210842108421</span>ULL) % <span class=number>0x1f</span>;</span><br><span class=line>c += (((v &amp; <span class=number>0xfff000</span>) &gt;&gt; <span class=number>12</span>) * <span class=number>0x1001001001001</span>ULL &amp; <span class=number>0x84210842108421</span>ULL) </span><br><span class=line>     % <span class=number>0x1f</span>;</span><br><span class=line></span><br><span class=line><span class=comment>// 针对至多32位长的v:</span></span><br><span class=line>c =  ((v &amp; <span class=number>0xfff</span>) * <span class=number>0x1001001001001</span>ULL &amp; <span class=number>0x84210842108421</span>ULL) % <span class=number>0x1f</span>;</span><br><span class=line>c += (((v &amp; <span class=number>0xfff000</span>) &gt;&gt; <span class=number>12</span>) * <span class=number>0x1001001001001</span>ULL &amp; <span class=number>0x84210842108421</span>ULL) % </span><br><span class=line>     <span class=number>0x1f</span>;</span><br><span class=line>c += ((v &gt;&gt; <span class=number>24</span>) * <span class=number>0x1001001001001</span>ULL &amp; <span class=number>0x84210842108421</span>ULL) % <span class=number>0x1f</span>;</span><br></pre></td></tr></table></figure><p>该方法需要能快速求余的64位CPU才能高效率。14位长的只需要3次操作；24位的需要10次；32位15次。</p><p>作者注：</p><ul><li>Rich Schroeppel最初原创了针对9位的求法，类似于我这里的14位的方法；详见<a href=http://www.inwap.com/pdp10/hbaker/hakmem/hakmem.html target=_blank rel=noopener>Beeler, M., Gosper, R. W., and Schroeppel, R. HAKMEM. MIT AI Memo 239, Feb. 29, 1972.</a>的Programming Hacks部分。它启发了Sean Anderson(译注：作者自己), 并想出了上面的几种方法。</li><li>2005年5月3日，Randal E. Bryant找出了一堆bug.</li><li>2007年2月1日，Bruce Dawson对12位方法做了微调，使之变成了现在的14位版本。</li></ul><h3 id=并行方法>并行方法</h3><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>unsigned</span> <span class=keyword>int</span> v; <span class=comment>// 要统计v(32位数值)</span></span><br><span class=line><span class=keyword>unsigned</span> <span class=keyword>int</span> c; <span class=comment>// 存放结果</span></span><br><span class=line><span class=keyword>static</span> <span class=keyword>const</span> <span class=keyword>int</span> S[] = &#123;<span class=number>1</span>, <span class=number>2</span>, <span class=number>4</span>, <span class=number>8</span>, <span class=number>16</span>&#125;; <span class=comment>// 二进制魔法数字</span></span><br><span class=line><span class=keyword>static</span> <span class=keyword>const</span> <span class=keyword>int</span> B[] = &#123;<span class=number>0x55555555</span>, <span class=number>0x33333333</span>, <span class=number>0x0F0F0F0F</span>, <span class=number>0x00FF00FF</span>, <span class=number>0x0000FFFF</span>&#125;;</span><br><span class=line></span><br><span class=line>c = v - ((v &gt;&gt; <span class=number>1</span>) &amp; B[<span class=number>0</span>]);</span><br><span class=line>c = ((c &gt;&gt; S[<span class=number>1</span>]) &amp; B[<span class=number>1</span>]) + (c &amp; B[<span class=number>1</span>]);</span><br><span class=line>c = ((c &gt;&gt; S[<span class=number>2</span>]) + c) &amp; B[<span class=number>2</span>];</span><br><span class=line>c = ((c &gt;&gt; S[<span class=number>3</span>]) + c) &amp; B[<span class=number>3</span>];</span><br><span class=line>c = ((c &gt;&gt; S[<span class=number>4</span>]) + c) &amp; B[<span class=number>4</span>];</span><br></pre></td></tr></table></figure><p>数组<code>B</code>表示为二进制，就是：</p><figure class="highlight markdown"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre></td><td class=code><pre><span class=line>B[0] = 0x55555555 = 01010101 01010101 01010101 01010101</span><br><span class=line>B[1] = 0x33333333 = 00110011 00110011 00110011 00110011</span><br><span class=line>B[2] = 0x0F0F0F0F = 00001111 00001111 00001111 00001111</span><br><span class=line>B[3] = 0x00FF00FF = 00000000 11111111 00000000 11111111</span><br><span class=line>B[4] = 0x0000FFFF = 00000000 00000000 11111111 11111111</span><br></pre></td></tr></table></figure><p>对于大点的数据，我们可以延长魔法数字<code>B</code>和<code>S</code>来适配。如果数字有<code>k</code>位，数组<code>S</code>和<code>B</code>就应该有$\lceil \lg(k) \rceil$个元素，而且我们要写出关于<code>c</code>的同样多个数的表达式。对于一个32位长的<code>v</code>, 进行了16次操作。</p><p>对于一个32位整数<code>v</code>的最佳解法是：</p><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre></td><td class=code><pre><span class=line>v = v - ((v &gt;&gt; <span class=number>1</span>) &amp; <span class=number>0x55555555</span>);                    <span class=comment>// 用v来存储中间值</span></span><br><span class=line>v = (v &amp; <span class=number>0x33333333</span>) + ((v &gt;&gt; <span class=number>2</span>) &amp; <span class=number>0x33333333</span>);     <span class=comment>// 同上</span></span><br><span class=line>c = ((v + (v &gt;&gt; <span class=number>4</span>) &amp; <span class=number>0xF0F0F0F</span>) * <span class=number>0x1010101</span>) &gt;&gt; <span class=number>24</span>; <span class=comment>// 计数</span></span><br></pre></td></tr></table></figure><p>该解法只用了12次操作，与查表法的相同，并避免使用额外内存和缓存未命中表的情况。该解法混合了上面并行法和更前面的使用乘法的解法（使用64位指令集的那个解法），然而它并没有用到64位指令集。统计在并行部分完成，计数求和由乘以<code>0x1010101</code>并右移24位完成。</p><p>一个最佳通用解法如下，它最多支持到128位（参数化表示为<code>T</code>）：</p><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre></td><td class=code><pre><span class=line>v = v - ((v &gt;&gt; <span class=number>1</span>) &amp; (T)~(T)<span class=number>0</span>/<span class=number>3</span>);                           <span class=comment>// 中间值</span></span><br><span class=line>v = (v &amp; (T)~(T)<span class=number>0</span>/<span class=number>15</span>*<span class=number>3</span>) + ((v &gt;&gt; <span class=number>2</span>) &amp; (T)~(T)<span class=number>0</span>/<span class=number>15</span>*<span class=number>3</span>);      <span class=comment>// 同上</span></span><br><span class=line>v = (v + (v &gt;&gt; <span class=number>4</span>)) &amp; (T)~(T)<span class=number>0</span>/<span class=number>255</span>*<span class=number>15</span>;                      <span class=comment>// 同上</span></span><br><span class=line>c = (T)(v * ((T)~(T)<span class=number>0</span>/<span class=number>255</span>)) &gt;&gt; (<span class=keyword>sizeof</span>(T) - <span class=number>1</span>) * CHAR_BIT; <span class=comment>// 计数</span></span><br></pre></td></tr></table></figure><p>作者注：</p><ul><li>更多信息见Ian Ashdown的<a href="http://groups.google.com/groups?q=reverse+bits&amp;num=100&amp;hl=en&amp;group=comp.graphics.algorithms&amp;imgsafe=off&amp;safe=off&amp;rnum=2&amp;ic=1&amp;selm=4fulhm%248dn%40atlas.uniserve.com" target=_blank rel=noopener>贴子</a>。</li><li>最佳解法是2005年10月5日由Andrew Shapira告诉我的；他在<a href=http://www.amd.com/us-en/assets/content_type/white_papers_and_tech_docs/25112.PDF target=_blank rel=noopener>Software Optimization Guide for AMD Athlon™ 64 and Opteron™ Processors</a>的187-188页找到了它。</li><li>2005年12月14日Charlie Gordon给了我一个能优化掉一次操作的建议。</li><li>2005年12月30日Don Clugston从中整理出了三种方法。</li><li>我接受了建议后又犯了几个拼写错误，于2006年1月8日由Eric Cole指出。此后，他给了上面那个通用解法的建议。</li><li>2007年4月5日，Al Williams告知我在最开始的方法里有一句冗余代码。</li></ul><h3 id=从最高位到指定位>从最高位到指定位</h3><p>下面给出求从最高位到指定位<code>1</code>的个数（rank）的解法：</p><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>uint64_t</span> v;       <span class=comment>// 待计算的数v</span></span><br><span class=line><span class=keyword>unsigned</span> <span class=keyword>int</span> pos; <span class=comment>// 指定的位置</span></span><br><span class=line><span class=keyword>uint64_t</span> r;       <span class=comment>// 存放结果</span></span><br><span class=line></span><br><span class=line><span class=comment>// 将给定位置以下的数字删除.</span></span><br><span class=line>r = v &gt;&gt; (<span class=keyword>sizeof</span>(v) * CHAR_BIT - pos);</span><br><span class=line><span class=comment>// 并行计算</span></span><br><span class=line><span class=comment>// r = (r &amp; 0x5555...) + ((r &gt;&gt; 1) &amp; 0x5555...);</span></span><br><span class=line>r = r - ((r &gt;&gt; <span class=number>1</span>) &amp; ~<span class=number>0U</span>L/<span class=number>3</span>);</span><br><span class=line><span class=comment>// r = (r &amp; 0x3333...) + ((r &gt;&gt; 2) &amp; 0x3333...);</span></span><br><span class=line>r = (r &amp; ~<span class=number>0U</span>L/<span class=number>5</span>) + ((r &gt;&gt; <span class=number>2</span>) &amp; ~<span class=number>0U</span>L/<span class=number>5</span>);</span><br><span class=line><span class=comment>// r = (r &amp; 0x0f0f...) + ((r &gt;&gt; 4) &amp; 0x0f0f...);</span></span><br><span class=line>r = (r + (r &gt;&gt; <span class=number>4</span>)) &amp; ~<span class=number>0U</span>L/<span class=number>17</span>;</span><br><span class=line><span class=comment>// r = r % 255;</span></span><br><span class=line>r = (r * (~<span class=number>0U</span>L/<span class=number>255</span>)) &gt;&gt; ((<span class=keyword>sizeof</span>(v) - <span class=number>1</span>) * CHAR_BIT);</span><br></pre></td></tr></table></figure><p>作者注：</p><ul><li>2009年11月21日，Juha Järvi给了我这个下面问题的镜像问题。</li></ul><h3 id=已知rank求出位数>已知rank求出位数</h3><p>下面的64位代码计算出从左至右第<code>r</code>个<code>1</code>. 也就是说，从最高位向右统计1的个数，直到得到rank<code>r</code>, 返回对应的这个位。如果给出的rank超出了范围，返回<code>64</code>. 代码可以针对32位或者从左往右计算做出修改。</p><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>uint64_t</span> v;          <span class=comment>// 待计算的数v</span></span><br><span class=line><span class=keyword>unsigned</span> <span class=keyword>int</span> r;      <span class=comment>// 输入rank, 范围是1~64.</span></span><br><span class=line><span class=keyword>unsigned</span> <span class=keyword>int</span> s;      <span class=comment>// 输出rank对应的位数</span></span><br><span class=line><span class=keyword>uint64_t</span> a, b, c, d; <span class=comment>// 中间变量</span></span><br><span class=line><span class=keyword>unsigned</span> <span class=keyword>int</span> t;      <span class=comment>// 位数统计</span></span><br><span class=line></span><br><span class=line><span class=comment>// 对64位整数做并行处理，中间结果都存储起来</span></span><br><span class=line><span class=comment>// a = (v &amp; 0x5555...) + ((v &gt;&gt; 1) &amp; 0x5555...);</span></span><br><span class=line>a =  v - ((v &gt;&gt; <span class=number>1</span>) &amp; ~<span class=number>0U</span>L/<span class=number>3</span>);</span><br><span class=line><span class=comment>// b = (a &amp; 0x3333...) + ((a &gt;&gt; 2) &amp; 0x3333...);</span></span><br><span class=line>b = (a &amp; ~<span class=number>0U</span>L/<span class=number>5</span>) + ((a &gt;&gt; <span class=number>2</span>) &amp; ~<span class=number>0U</span>L/<span class=number>5</span>);</span><br><span class=line><span class=comment>// c = (b &amp; 0x0f0f...) + ((b &gt;&gt; 4) &amp; 0x0f0f...);</span></span><br><span class=line>c = (b + (b &gt;&gt; <span class=number>4</span>)) &amp; ~<span class=number>0U</span>L/<span class=number>0x11</span>;</span><br><span class=line><span class=comment>// d = (c &amp; 0x00ff...) + ((c &gt;&gt; 8) &amp; 0x00ff...);</span></span><br><span class=line>d = (c + (c &gt;&gt; <span class=number>8</span>)) &amp; ~<span class=number>0U</span>L/<span class=number>0x101</span>;</span><br><span class=line>t = (d &gt;&gt; <span class=number>32</span>) + (d &gt;&gt; <span class=number>48</span>);</span><br><span class=line><span class=comment>// 开始不使用条件分支的计算</span></span><br><span class=line>s  = <span class=number>64</span>;</span><br><span class=line><span class=comment>// if (r &gt; t) &#123;s -= 32; r -= t;&#125;</span></span><br><span class=line>s -= ((t - r) &amp; <span class=number>256</span>) &gt;&gt; <span class=number>3</span>; r -= (t &amp; ((t - r) &gt;&gt; <span class=number>8</span>));</span><br><span class=line>t  = (d &gt;&gt; (s - <span class=number>16</span>)) &amp; <span class=number>0xff</span>;</span><br><span class=line><span class=comment>// if (r &gt; t) &#123;s -= 16; r -= t;&#125;</span></span><br><span class=line>s -= ((t - r) &amp; <span class=number>256</span>) &gt;&gt; <span class=number>4</span>; r -= (t &amp; ((t - r) &gt;&gt; <span class=number>8</span>));</span><br><span class=line>t  = (c &gt;&gt; (s - <span class=number>8</span>)) &amp; <span class=number>0xf</span>;</span><br><span class=line><span class=comment>// if (r &gt; t) &#123;s -= 8; r -= t;&#125;</span></span><br><span class=line>s -= ((t - r) &amp; <span class=number>256</span>) &gt;&gt; <span class=number>5</span>; r -= (t &amp; ((t - r) &gt;&gt; <span class=number>8</span>));</span><br><span class=line>t  = (b &gt;&gt; (s - <span class=number>4</span>)) &amp; <span class=number>0x7</span>;</span><br><span class=line><span class=comment>// if (r &gt; t) &#123;s -= 4; r -= t;&#125;</span></span><br><span class=line>s -= ((t - r) &amp; <span class=number>256</span>) &gt;&gt; <span class=number>6</span>; r -= (t &amp; ((t - r) &gt;&gt; <span class=number>8</span>));</span><br><span class=line>t  = (a &gt;&gt; (s - <span class=number>2</span>)) &amp; <span class=number>0x3</span>;</span><br><span class=line><span class=comment>// if (r &gt; t) &#123;s -= 2; r -= t;&#125;</span></span><br><span class=line>s -= ((t - r) &amp; <span class=number>256</span>) &gt;&gt; <span class=number>7</span>; r -= (t &amp; ((t - r) &gt;&gt; <span class=number>8</span>));</span><br><span class=line>t  = (v &gt;&gt; (s - <span class=number>1</span>)) &amp; <span class=number>0x1</span>;</span><br><span class=line><span class=comment>// if (r &gt; t) s--;</span></span><br><span class=line>s -= ((t - r) &amp; <span class=number>256</span>) &gt;&gt; <span class=number>8</span>;</span><br><span class=line>s = <span class=number>65</span> - s;</span><br></pre></td></tr></table></figure><p>如果分支在你的CPU上速度很快的话，取消使用注释里的条件语句进行替换。</p><h2 id=奇偶校验>奇偶校验</h2><p>译注：信息是以比特流的方式传输的，类似<code>01000001</code>. 在传输过程中，有可能会发生错误，比如，我们存储了<code>01000001</code>，但是取出来却是<code>01000000</code>，即低位由0变成了1。为了检测到这种错误，我们可以通过“奇偶校验”来实现。假如，我们存储的数据是一个字节，8个比特位，那我们就可以计算每个字节比特位是<code>1</code>的个数，如果是偶数个<code>1</code>，那么，我们就把第九个位设为<code>1</code>，如果是奇数个<code>1</code>，那么就把第九个位设为<code>0</code>，这样连续9个字节比特位为<code>1</code>的位数肯定是奇数。这种方法叫做“奇校验”，“偶校验”和此类似。当然，在实际应用中，也可以把一个字节的前7位作为数据位，最后一个为作为校验位。</p><h3 id=简单粗暴的解法-v2>简单粗暴的解法</h3><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>unsigned</span> <span class=keyword>int</span> v;       <span class=comment>// 待检验的数v</span></span><br><span class=line><span class=keyword>bool</span> parity = <span class=literal>false</span>;  <span class=comment>// 存放结果，奇数个为true</span></span><br><span class=line></span><br><span class=line><span class=keyword>while</span> (v)</span><br><span class=line>&#123;</span><br><span class=line>  parity = !parity;</span><br><span class=line>  v = v &amp; (v - <span class=number>1</span>);</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><p>该解法使用了类似于前述Brian Kernigan解法的思路，消耗时间与二进制<code>1</code>的数量成正比。</p><h3 id=查表法-v2>查表法</h3><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>static</span> <span class=keyword>const</span> <span class=keyword>bool</span> ParityTable256[<span class=number>256</span>] = </span><br><span class=line>&#123;</span><br><span class=line>#   define P2(n) n, n^<span class=number>1</span>, n^<span class=number>1</span>, n</span><br><span class=line>#   define P4(n) P2(n), P2(n^<span class=number>1</span>), P2(n^<span class=number>1</span>), P2(n)</span><br><span class=line>#   define P6(n) P4(n), P4(n^<span class=number>1</span>), P4(n^<span class=number>1</span>), P4(n)</span><br><span class=line>    P6(<span class=number>0</span>), P6(<span class=number>1</span>), P6(<span class=number>1</span>), P6(<span class=number>0</span>)</span><br><span class=line>&#125;;</span><br><span class=line></span><br><span class=line><span class=keyword>unsigned</span> <span class=keyword>char</span> b;  <span class=comment>// 待计算的数b</span></span><br><span class=line><span class=keyword>bool</span> parity = ParityTable256[b];</span><br><span class=line></span><br><span class=line><span class=comment>// 针对32位长的数：</span></span><br><span class=line><span class=keyword>unsigned</span> <span class=keyword>int</span> v;</span><br><span class=line>v ^= v &gt;&gt; <span class=number>16</span>;</span><br><span class=line>v ^= v &gt;&gt; <span class=number>8</span>;</span><br><span class=line><span class=keyword>bool</span> parity = ParityTable256[v &amp; <span class=number>0xff</span>];</span><br><span class=line></span><br><span class=line><span class=comment>// 变体：</span></span><br><span class=line><span class=keyword>unsigned</span> <span class=keyword>char</span> * p = (<span class=keyword>unsigned</span> <span class=keyword>char</span> *) &amp;v;</span><br><span class=line>parity = ParityTable256[p[<span class=number>0</span>] ^ p[<span class=number>1</span>] ^ p[<span class=number>2</span>] ^ p[<span class=number>3</span>]];</span><br></pre></td></tr></table></figure><p>作者注：</p><ul><li>2005年5月3日Randal E. Bryant支持我加上那个很直接的解法（最后那个变体）。</li><li>2005年9月27日，Bruce Rawles找到了几个表名的拼写错误，并因此收到了$10的找bug奖金。</li><li>2006年10月9日，Fabrice Bellard给了我上面的32位长的版本，它只需一次查表，原来的版本需要4次查表，更慢。</li><li>2009年7月14日Hallvard Furuseth建议我使用宏来生成表。</li></ul><h3 id=使用64位指令集的乘法和求余>使用64位指令集的乘法和求余</h3><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>unsigned</span> <span class=keyword>char</span> b;  <span class=comment>// 待计算的数b</span></span><br><span class=line><span class=keyword>bool</span> parity = (((b * <span class=number>0x0101010101010101</span>ULL) &amp; <span class=number>0x8040201008040201</span>ULL) % <span class=number>0x1FF</span>) &amp; <span class=number>1</span>;</span><br></pre></td></tr></table></figure><p>上面的方法大概需要4次操作，但只对整字节有效。</p><h3 id=使用一次乘法>使用一次乘法</h3><p>以下方法能仅用8次操作处理一个32位长的数值，而且只用了一次乘法。</p><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>unsigned</span> <span class=keyword>int</span> v; <span class=comment>// 32-bit word</span></span><br><span class=line>v ^= v &gt;&gt; <span class=number>1</span>;</span><br><span class=line>v ^= v &gt;&gt; <span class=number>2</span>;</span><br><span class=line>v = (v &amp; <span class=number>0x11111111</span>U) * <span class=number>0x11111111</span>U;</span><br><span class=line><span class=keyword>return</span> (v &gt;&gt; <span class=number>28</span>) &amp; <span class=number>1</span>;</span><br></pre></td></tr></table></figure><p>对于64位长的，8次操作也足够：</p><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>unsigned</span> <span class=keyword>long</span> <span class=keyword>long</span> v; <span class=comment>// 64-bit word</span></span><br><span class=line>v ^= v &gt;&gt; <span class=number>1</span>;</span><br><span class=line>v ^= v &gt;&gt; <span class=number>2</span>;</span><br><span class=line>v = (v &amp; <span class=number>0x1111111111111111</span>UL) * <span class=number>0x1111111111111111</span>UL;</span><br><span class=line><span class=keyword>return</span> (v &gt;&gt; <span class=number>60</span>) &amp; <span class=number>1</span>;</span><br></pre></td></tr></table></figure><p>作者注：</p><ul><li>Andrew Shapira想出了这个方法并于2007年9月2日给了我。</li></ul><h3 id=并行法>并行法</h3><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>unsigned</span> <span class=keyword>int</span> v;</span><br><span class=line>v ^= v &gt;&gt; <span class=number>16</span>;</span><br><span class=line>v ^= v &gt;&gt; <span class=number>8</span>;</span><br><span class=line>v ^= v &gt;&gt; <span class=number>4</span>;</span><br><span class=line>v &amp;= <span class=number>0xf</span>;</span><br><span class=line><span class=keyword>return</span> (<span class=number>0x6996</span> &gt;&gt; v) &amp; <span class=number>1</span>;</span><br></pre></td></tr></table></figure><p>以上方法需要大概9次操作，对32位的有效。对于整字节也可以删掉<code>unsigned int v</code>后面的两行来优化到只用5次操作。该方法首先使用移位和异或对v的每段（每段8bit）进行处理，异或后只取后4个bit, 然后二进制数<code>0110 1001 1001 0110</code>(16进制是<code>0x6996</code>)右移这么多位。这就好像是拿<code>v</code>的后四位去小型的16位奇偶表里去查。<code>v</code>的奇偶结果以二进制<code>1</code>的形式保存并返回。</p><p>作者注：</p><ul><li>感谢Mathew Hendry于2002年12月15日告诉我的移位-查表方法。优化后能少两次操作并且只用了移位和异或。</li></ul><h2 id=交换两个数的值>交换两个数的值</h2><h3 id=使用加减法>使用加减法</h3><p>译注：不要把右值往<code>a</code>, <code>b</code>里代入。</p><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre></td><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>define</span> SWAP(a, b) ((&amp;(a) == &amp;(b)) || \</span></span><br><span class=line>                    (((a) -= (b)), ((b) += (a)), ((a) = (b) - (a))))</span><br></pre></td></tr></table></figure><p>该方法能不使用额外的临时变量来交换<code>a</code>和<code>b</code>的值。开始的那句是检查<code>a</code>与<code>b</code>是否使用了同一块内存空间，是的话那么该方法结果就不对了（编译器可能会把这个检查优化掉）。如果你开启了溢出异常检测，那么要传递无符号值以避免触发异常。下面的异或方法在某些机器上可能会快一点。不要对浮点数也这么操作，除非你操作的是它们的二进制值。</p><p>作者注：</p><ul><li>2007年6月12日Sanjeev Sivasankaran建议我加上这一条。</li><li>2008年7月9日Vincent Lefèvre指出它有潜在的溢出风险。</li></ul><h3 id=使用异或>使用异或</h3><p>译注：同上。</p><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line><span class=meta>#<span class=meta-keyword>define</span> SWAP(a, b) (((a) ^= (b)), ((b) ^= (a)), ((a) ^= (b)))</span></span><br></pre></td></tr></table></figure><p>这是一种很古老的，不使用额外临时变量的交换技巧。</p><p>作者注：</p><ul><li>2005年1月20日，Iain A. Fleming指出该方法当作用于同一内存空间的时候失效，比如我当<code>i==j</code>的时候<code>SWAP(a[i], a[j])</code>. 所以为避免这种情况的发生，把宏定义改成<code>(((a) == (b)) || (((a) ^= (b)), ((b) ^= (a)), ((a) ^= (b))))</code>.</li><li>2009年7月14日，Hallvard Furuseth告诉我说，在某些机器上<code>(((a) ^ (b)) &amp;&amp; ((b) ^= (a) ^= (b), (a) ^= (b)))</code>会更快一点，因为<code>(a) ^ (b)</code>的值能重复利用。</li></ul><h3 id=交换指定的某几个二进制位>交换指定的某几个二进制位</h3><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>unsigned</span> <span class=keyword>int</span> i, j; <span class=comment>// 给定位置</span></span><br><span class=line><span class=keyword>unsigned</span> <span class=keyword>int</span> n;    <span class=comment>// 想交换多少位</span></span><br><span class=line><span class=keyword>unsigned</span> <span class=keyword>int</span> b;    <span class=comment>// 被交换数b</span></span><br><span class=line><span class=keyword>unsigned</span> <span class=keyword>int</span> r;    <span class=comment>// 交换结果</span></span><br><span class=line></span><br><span class=line><span class=keyword>unsigned</span> <span class=keyword>int</span> x = ((b &gt;&gt; i) ^ (b &gt;&gt; j)) &amp; ((<span class=number>1U</span> &lt;&lt; n) - <span class=number>1</span>); <span class=comment>// 中间变量</span></span><br><span class=line>r = b ^ ((x &lt;&lt; i) | (x &lt;&lt; j));</span><br></pre></td></tr></table></figure><p>举个例子，假如我们有个数<code>b = 00101111</code>(二进制表示)，我们想把它里面从<code>i = 1</code>开始的连续<code>n = 3</code>位与从<code>j = 5</code>开始的连续<code>n</code>位交换，其结果应该是<code>r = 11100011</code>(二进制表示)。</p><p>该方法的思路与异或法相似。<code>x</code>用于保存我们想要交换的那几位，然后这几位的值被赋值为它们自己与<code>x</code>的异或结果。当然，如果序列超出范围其结果未定义。</p><p>作者注：</p><ul><li>2009年7月14日，Hallvard Furuseth建议我把<code>1 &lt;&lt; n</code>改成<code>1U &lt;&lt; n</code>来强行赋值为无符号型来避免对意外地有符号数移位。</li></ul><h2 id=倒置二进制位>倒置二进制位</h2><h3 id=直接解法>直接解法</h3><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>unsigned</span> <span class=keyword>int</span> v;     <span class=comment>// 待处理的数v</span></span><br><span class=line><span class=keyword>unsigned</span> <span class=keyword>int</span> r = v; <span class=comment>// r存放结果</span></span><br><span class=line><span class=keyword>int</span> s = <span class=keyword>sizeof</span>(v) * CHAR_BIT - <span class=number>1</span>; <span class=comment>// 最后一步的额外处理</span></span><br><span class=line></span><br><span class=line><span class=keyword>for</span> (v &gt;&gt;= <span class=number>1</span>; v; v &gt;&gt;= <span class=number>1</span>)</span><br><span class=line>&#123;</span><br><span class=line>  r &lt;&lt;= <span class=number>1</span>;</span><br><span class=line>  r |= v &amp; <span class=number>1</span>;</span><br><span class=line>  s--;</span><br><span class=line>&#125;</span><br><span class=line>r &lt;&lt;= s; <span class=comment>// 当v的最高位是0的时候移位</span></span><br></pre></td></tr></table></figure><p>作者注：</p><ul><li>2004年10月15日，Michael Hoisie指出最初版本有一个bug.</li><li>2005年5月3日Randal E. Bryant建议我删掉一个冗余操作。2005年5月18日Behdad Esfabod给了我一个小建议，它能减少一次循环。</li><li>2007年2月6日，Liyong Zhou给了我点建议，使得循环只在<code>v</code>不是0的时候运行，而不是对每一位都循环一次。</li></ul><h3 id=查表法-v3>查表法</h3><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>static</span> <span class=keyword>const</span> <span class=keyword>unsigned</span> <span class=keyword>char</span> BitReverseTable256[<span class=number>256</span>] = </span><br><span class=line>&#123;</span><br><span class=line>#   define R2(n)     n,     n + <span class=number>2</span>*<span class=number>64</span>,     n + <span class=number>1</span>*<span class=number>64</span>,     n + <span class=number>3</span>*<span class=number>64</span></span><br><span class=line>#   define R4(n) R2(n), R2(n + <span class=number>2</span>*<span class=number>16</span>), R2(n + <span class=number>1</span>*<span class=number>16</span>), R2(n + <span class=number>3</span>*<span class=number>16</span>)</span><br><span class=line>#   define R6(n) R4(n), R4(n + <span class=number>2</span>*<span class=number>4</span> ), R4(n + <span class=number>1</span>*<span class=number>4</span> ), R4(n + <span class=number>3</span>*<span class=number>4</span> )</span><br><span class=line>    R6(<span class=number>0</span>), R6(<span class=number>2</span>), R6(<span class=number>1</span>), R6(<span class=number>3</span>)</span><br><span class=line>&#125;;</span><br><span class=line></span><br><span class=line><span class=keyword>unsigned</span> <span class=keyword>int</span> v; <span class=comment>// 32位值，每次倒置8位</span></span><br><span class=line><span class=keyword>unsigned</span> <span class=keyword>int</span> c; <span class=comment>// v倒置的结果</span></span><br><span class=line></span><br><span class=line><span class=comment>// Option 1:</span></span><br><span class=line>c = (BitReverseTable256[v &amp; <span class=number>0xff</span>] &lt;&lt; <span class=number>24</span>) | </span><br><span class=line>    (BitReverseTable256[(v &gt;&gt; <span class=number>8</span>) &amp; <span class=number>0xff</span>] &lt;&lt; <span class=number>16</span>) | </span><br><span class=line>    (BitReverseTable256[(v &gt;&gt; <span class=number>16</span>) &amp; <span class=number>0xff</span>] &lt;&lt; <span class=number>8</span>) |</span><br><span class=line>    (BitReverseTable256[(v &gt;&gt; <span class=number>24</span>) &amp; <span class=number>0xff</span>]);</span><br><span class=line></span><br><span class=line><span class=comment>// Option 2:</span></span><br><span class=line><span class=keyword>unsigned</span> <span class=keyword>char</span> * p = (<span class=keyword>unsigned</span> <span class=keyword>char</span> *) &amp;v;</span><br><span class=line><span class=keyword>unsigned</span> <span class=keyword>char</span> * q = (<span class=keyword>unsigned</span> <span class=keyword>char</span> *) &amp;c;</span><br><span class=line>q[<span class=number>3</span>] = BitReverseTable256[p[<span class=number>0</span>]]; </span><br><span class=line>q[<span class=number>2</span>] = BitReverseTable256[p[<span class=number>1</span>]]; </span><br><span class=line>q[<span class=number>1</span>] = BitReverseTable256[p[<span class=number>2</span>]]; </span><br><span class=line>q[<span class=number>0</span>] = BitReverseTable256[p[<span class=number>3</span>]];</span><br></pre></td></tr></table></figure><p>第一个方法要用17次操作，第二种需要12次，如果你的CPU能够快速读取和存储数据的话。</p><p>作者注：</p><ul><li>2009年7月14日Hallvard Furuseth建议我使用宏来生成表。</li></ul><h3 id=倒置一比特-仅用3次操作-使用64位的乘法和求余>倒置一比特，仅用3次操作（使用64位的乘法和求余）</h3><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>unsigned</span> <span class=keyword>char</span> b; <span class=comment>// reverse this (8-bit) byte</span></span><br><span class=line> </span><br><span class=line>b = (b * <span class=number>0x0202020202</span>ULL &amp; <span class=number>0x010884422010</span>ULL) % <span class=number>1023</span>;</span><br></pre></td></tr></table></figure><p>乘法操作生成了五分相互独立的拷贝，每份8位，并合并成一个64位值。将该值分为每十位一组，与操作选出哪些位在组中正确的（倒置）位上。乘法和与运算从原数据拷贝到这里来，所以每个组中一定会有一个原数据。比特位的倒置位置与它们在组中的相对位置相同。最后，求得模<code>2^10 - 1</code>的余数，即能把每组中的选中的比特位聚合到一起。它们相互不会覆盖，所以求余操作的底层操作就像逻辑或操作一样。</p><p>该方法见于<a href=http://www.inwap.com/pdp10/hbaker/hakmem/hakmem.html target=_blank rel=noopener>Beeler, M., Gosper, R. W., and Schroeppel, R. HAKMEM. MIT AI Memo 239, Feb. 29, 1972.</a>的Programming Hacks部分。</p><h3 id=倒置一比特-仅用4次操作-使用64位的乘法-不使用除法>倒置一比特，仅用4次操作（使用64位的乘法，不使用除法）</h3><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>unsigned</span> <span class=keyword>char</span> b; <span class=comment>// reverse this byte</span></span><br><span class=line> </span><br><span class=line>b = ((b * <span class=number>0x80200802</span>ULL) &amp; <span class=number>0x0884422110</span>ULL) * <span class=number>0x0101010101</span>ULL &gt;&gt; <span class=number>32</span>;</span><br></pre></td></tr></table></figure><p>下面就是该方法的原理展示，使用<code>a</code>,<code>b</code>,<code>c</code>,<code>d</code>,<code>e</code>,<code>f</code>,<code>g</code>,<code>h</code>来表示该比特的各个位。注意第一次乘法是如何将这个数拷贝多份的。以及最后一次乘法是如何将这几个位合并到从右往左数第五个比特中去的。</p><figure class="highlight plain"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre></td><td class=code><pre><span class=line>                                                                                        abcd efgh (-&gt; hgfe dcba)</span><br><span class=line>*                                                      1000 0000  0010 0000  0000 1000  0000 0010 (0x80200802)</span><br><span class=line>-------------------------------------------------------------------------------------------------</span><br><span class=line>                                            0abc defg  h00a bcde  fgh0 0abc  defg h00a  bcde fgh0</span><br><span class=line>&amp;                                           0000 1000  1000 0100  0100 0010  0010 0001  0001 0000 (0x0884422110)</span><br><span class=line>-------------------------------------------------------------------------------------------------</span><br><span class=line>                                            0000 d000  h000 0c00  0g00 00b0  00f0 000a  000e 0000</span><br><span class=line>*                                           0000 0001  0000 0001  0000 0001  0000 0001  0000 0001 (0x0101010101)</span><br><span class=line>-------------------------------------------------------------------------------------------------</span><br><span class=line>                                            0000 d000  h000 0c00  0g00 00b0  00f0 000a  000e 0000</span><br><span class=line>                                 0000 d000  h000 0c00  0g00 00b0  00f0 000a  000e 0000</span><br><span class=line>                      0000 d000  h000 0c00  0g00 00b0  00f0 000a  000e 0000</span><br><span class=line>           0000 d000  h000 0c00  0g00 00b0  00f0 000a  000e 0000</span><br><span class=line>0000 d000  h000 0c00  0g00 00b0  00f0 000a  000e 0000</span><br><span class=line>-------------------------------------------------------------------------------------------------</span><br><span class=line>0000 d000  h000 dc00  hg00 dcb0  hgf0 dcba  hgfe dcba  hgfe 0cba  0gfe 00ba  00fe 000a  000e 0000</span><br><span class=line>&gt;&gt; 32</span><br><span class=line>-------------------------------------------------------------------------------------------------</span><br><span class=line>                                            0000 d000  h000 dc00  hg00 dcb0  hgf0 dcba  hgfe dcba</span><br><span class=line>&amp;                                                                                       1111 1111</span><br><span class=line>-------------------------------------------------------------------------------------------------</span><br><span class=line>                                                                                        hgfe dcba</span><br></pre></td></tr></table></figure><p>最后两步可以合并，因为某些处理器的寄存器可以按照字节来读写；只用乘法，然后寄存器存储高位的32位，再取低八位，这样就只要6次操作。</p><p>该方法于2001年7月13日由Sean Anderson创造而出。</p><h3 id=倒置一比特-仅用7次操作-不使用64位>倒置一比特，仅用7次操作（不使用64位）</h3><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line>b = ((b * <span class=number>0x0802</span>LU &amp; <span class=number>0x22110</span>LU) | (b * <span class=number>0x8020</span>LU &amp; <span class=number>0x88440</span>LU)) * <span class=number>0x10101</span>LU &gt;&gt; <span class=number>16</span>;</span><br></pre></td></tr></table></figure><p>注意要把结果赋值给或转换到<code>unsigned char</code>以去除不需要的垃圾位。</p><p>作者注：</p><ul><li>2001年7月13日，该方法由Sean Anderson创造而出。</li><li>2002年1月3日，Mike Keith指出并修正了拼写错误。</li></ul><h3 id=倒置n位-并行法-使用-5-lg-n-次操作>倒置N位，并行法，使用 5*lg(N) 次操作</h3><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>unsigned</span> <span class=keyword>int</span> v; <span class=comment>// 32-bit word to reverse bit order</span></span><br><span class=line></span><br><span class=line><span class=comment>// swap odd and even bits</span></span><br><span class=line>v = ((v &gt;&gt; <span class=number>1</span>) &amp; <span class=number>0x55555555</span>) | ((v &amp; <span class=number>0x55555555</span>) &lt;&lt; <span class=number>1</span>);</span><br><span class=line><span class=comment>// swap consecutive pairs</span></span><br><span class=line>v = ((v &gt;&gt; <span class=number>2</span>) &amp; <span class=number>0x33333333</span>) | ((v &amp; <span class=number>0x33333333</span>) &lt;&lt; <span class=number>2</span>);</span><br><span class=line><span class=comment>// swap nibbles ... </span></span><br><span class=line>v = ((v &gt;&gt; <span class=number>4</span>) &amp; <span class=number>0x0F0F0F0F</span>) | ((v &amp; <span class=number>0x0F0F0F0F</span>) &lt;&lt; <span class=number>4</span>);</span><br><span class=line><span class=comment>// swap bytes</span></span><br><span class=line>v = ((v &gt;&gt; <span class=number>8</span>) &amp; <span class=number>0x00FF00FF</span>) | ((v &amp; <span class=number>0x00FF00FF</span>) &lt;&lt; <span class=number>8</span>);</span><br><span class=line><span class=comment>// swap 2-byte long pairs</span></span><br><span class=line>v = ( v &gt;&gt; <span class=number>16</span>             ) | ( v               &lt;&lt; <span class=number>16</span>);</span><br></pre></td></tr></table></figure><p>下面的变体依然是$O(\lg N)$的，不过它需要更多次操作来倒置<code>v</code>. 它好在即时计算常量来减少内存使用。</p><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>unsigned</span> <span class=keyword>int</span> s = <span class=keyword>sizeof</span>(v) * CHAR_BIT; <span class=comment>// bit位数，必须是2的次幂</span></span><br><span class=line><span class=keyword>unsigned</span> <span class=keyword>int</span> mask = ~<span class=number>0</span>;</span><br><span class=line><span class=keyword>while</span> ((s &gt;&gt;= <span class=number>1</span>) &gt; <span class=number>0</span>) </span><br><span class=line>&#123;</span><br><span class=line>  mask ^= (mask &lt;&lt; s);</span><br><span class=line>  v = ((v &gt;&gt; s) &amp; mask) | ((v &lt;&lt; s) &amp; ~mask);</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><p>以上方法非常适合于N很大的情形。对于64位或以上的整数，还得按照套路加几行，否则只有低32位被倒置。</p><p>作者注：</p><ul><li>更多内容详见Dr. Dobb’s Journal 1983, Edwin Freed关于Binary Magic Numbers的文章。</li><li>2005年9月13日，Ken Raeburn推荐给我第二种变体。</li><li>2006年3月19日，Veldmeijer提出第一种方法的最后一行可以不使用与运算。</li></ul><h2 id=求余除法>求余除法</h2><h3 id=不使用除法-计算关于-1-s-的余数>不使用除法，计算关于 1&lt;&lt;s 的余数</h3><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>const</span> <span class=keyword>unsigned</span> <span class=keyword>int</span> n;          <span class=comment>// 被除数</span></span><br><span class=line><span class=keyword>const</span> <span class=keyword>unsigned</span> <span class=keyword>int</span> s;</span><br><span class=line><span class=keyword>const</span> <span class=keyword>unsigned</span> <span class=keyword>int</span> d = <span class=number>1U</span> &lt;&lt; s; <span class=comment>// So d will be one of: 1, 2, 4, 8, 16, 32, ...</span></span><br><span class=line><span class=keyword>unsigned</span> <span class=keyword>int</span> m;                <span class=comment>// m will be n % d</span></span><br><span class=line>m = n &amp; (d - <span class=number>1</span>);</span><br></pre></td></tr></table></figure><p>大部分程序员很早就知道这个技巧了，为了完整性我将其添加进来。</p><h3 id=不使用除法-计算关于-1-s-1-的余数>不使用除法，计算关于 (1&lt;&lt;s) - 1 的余数</h3><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>unsigned</span> <span class=keyword>int</span> n;                      <span class=comment>// 被除数</span></span><br><span class=line><span class=keyword>const</span> <span class=keyword>unsigned</span> <span class=keyword>int</span> s;                <span class=comment>// s &gt; 0</span></span><br><span class=line><span class=keyword>const</span> <span class=keyword>unsigned</span> <span class=keyword>int</span> d = (<span class=number>1</span> &lt;&lt; s) - <span class=number>1</span>; <span class=comment>// so d is either 1, 3, 7, 15, 31, ...).</span></span><br><span class=line><span class=keyword>unsigned</span> <span class=keyword>int</span> m;                      <span class=comment>// n % d goes here.</span></span><br><span class=line></span><br><span class=line><span class=keyword>for</span> (m = n; n &gt; d; n = m)</span><br><span class=line>&#123;</span><br><span class=line>  <span class=keyword>for</span> (m = <span class=number>0</span>; n; n &gt;&gt;= s)</span><br><span class=line>  &#123;</span><br><span class=line>    m += n &amp; d;</span><br><span class=line>  &#125;</span><br><span class=line>&#125;</span><br><span class=line><span class=comment>// m值域为[0,d], 但m是余数所以m为d时赋值为0</span></span><br><span class=line>m = m == d ? <span class=number>0</span> : m;</span><br></pre></td></tr></table></figure><p>求关于 $2^N-1$ 的余数需要 $5 + (4 + 5 \lceil {N \over s} \rceil) \cdot \lceil \lg{N \over s} \rceil$ 次操作，其中<code>N</code>是被除数的位数。也就是说，时间复杂度为$O(\lg N)$.</p><p>作者注：</p><ul><li>该方法于2001年8月15日由Sean Anderson想出。</li><li>在2004年6月17日Sean A. Irvine指正之前，我错误地评论说可以在最末尾使用<code>m = ((m + 1) &amp; d) - 1;</code>.</li><li>2005年4月25日，Michael Miller指出代码中一处拼写错误。</li></ul><h3 id=不使用除法-并行计算关于-1-s-1-的余数>不使用除法，并行计算关于 (1&lt;&lt;s) - 1 的余数</h3><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br></pre></td><td class=code><pre><span class=line><span class=comment>// The following is for a word size of 32 bits!</span></span><br><span class=line></span><br><span class=line><span class=keyword>static</span> <span class=keyword>const</span> <span class=keyword>unsigned</span> <span class=keyword>int</span> M[] = </span><br><span class=line>&#123;</span><br><span class=line>  <span class=number>0x00000000</span>, <span class=number>0x55555555</span>, <span class=number>0x33333333</span>, <span class=number>0xc71c71c7</span>,</span><br><span class=line>  <span class=number>0x0f0f0f0f</span>, <span class=number>0xc1f07c1f</span>, <span class=number>0x3f03f03f</span>, <span class=number>0xf01fc07f</span>, </span><br><span class=line>  <span class=number>0x00ff00ff</span>, <span class=number>0x07fc01ff</span>, <span class=number>0x3ff003ff</span>, <span class=number>0xffc007ff</span>,</span><br><span class=line>  <span class=number>0xff000fff</span>, <span class=number>0xfc001fff</span>, <span class=number>0xf0003fff</span>, <span class=number>0xc0007fff</span>,</span><br><span class=line>  <span class=number>0x0000ffff</span>, <span class=number>0x0001ffff</span>, <span class=number>0x0003ffff</span>, <span class=number>0x0007ffff</span>, </span><br><span class=line>  <span class=number>0x000fffff</span>, <span class=number>0x001fffff</span>, <span class=number>0x003fffff</span>, <span class=number>0x007fffff</span>,</span><br><span class=line>  <span class=number>0x00ffffff</span>, <span class=number>0x01ffffff</span>, <span class=number>0x03ffffff</span>, <span class=number>0x07ffffff</span>,</span><br><span class=line>  <span class=number>0x0fffffff</span>, <span class=number>0x1fffffff</span>, <span class=number>0x3fffffff</span>, <span class=number>0x7fffffff</span></span><br><span class=line>&#125;;</span><br><span class=line></span><br><span class=line><span class=keyword>static</span> <span class=keyword>const</span> <span class=keyword>unsigned</span> <span class=keyword>int</span> Q[][<span class=number>6</span>] = </span><br><span class=line>&#123;</span><br><span class=line>  &#123; <span class=number>0</span>,  <span class=number>0</span>,  <span class=number>0</span>,  <span class=number>0</span>,  <span class=number>0</span>,  <span class=number>0</span>&#125;, &#123;<span class=number>16</span>,  <span class=number>8</span>,  <span class=number>4</span>,  <span class=number>2</span>,  <span class=number>1</span>,  <span class=number>1</span>&#125;, &#123;<span class=number>16</span>,  <span class=number>8</span>,  <span class=number>4</span>,  <span class=number>2</span>,  <span class=number>2</span>,  <span class=number>2</span>&#125;,</span><br><span class=line>  &#123;<span class=number>15</span>,  <span class=number>6</span>,  <span class=number>3</span>,  <span class=number>3</span>,  <span class=number>3</span>,  <span class=number>3</span>&#125;, &#123;<span class=number>16</span>,  <span class=number>8</span>,  <span class=number>4</span>,  <span class=number>4</span>,  <span class=number>4</span>,  <span class=number>4</span>&#125;, &#123;<span class=number>15</span>,  <span class=number>5</span>,  <span class=number>5</span>,  <span class=number>5</span>,  <span class=number>5</span>,  <span class=number>5</span>&#125;,</span><br><span class=line>  &#123;<span class=number>12</span>,  <span class=number>6</span>,  <span class=number>6</span>,  <span class=number>6</span> , <span class=number>6</span>,  <span class=number>6</span>&#125;, &#123;<span class=number>14</span>,  <span class=number>7</span>,  <span class=number>7</span>,  <span class=number>7</span>,  <span class=number>7</span>,  <span class=number>7</span>&#125;, &#123;<span class=number>16</span>,  <span class=number>8</span>,  <span class=number>8</span>,  <span class=number>8</span>,  <span class=number>8</span>,  <span class=number>8</span>&#125;,</span><br><span class=line>  &#123; <span class=number>9</span>,  <span class=number>9</span>,  <span class=number>9</span>,  <span class=number>9</span>,  <span class=number>9</span>,  <span class=number>9</span>&#125;, &#123;<span class=number>10</span>, <span class=number>10</span>, <span class=number>10</span>, <span class=number>10</span>, <span class=number>10</span>, <span class=number>10</span>&#125;, &#123;<span class=number>11</span>, <span class=number>11</span>, <span class=number>11</span>, <span class=number>11</span>, <span class=number>11</span>, <span class=number>11</span>&#125;,</span><br><span class=line>  &#123;<span class=number>12</span>, <span class=number>12</span>, <span class=number>12</span>, <span class=number>12</span>, <span class=number>12</span>, <span class=number>12</span>&#125;, &#123;<span class=number>13</span>, <span class=number>13</span>, <span class=number>13</span>, <span class=number>13</span>, <span class=number>13</span>, <span class=number>13</span>&#125;, &#123;<span class=number>14</span>, <span class=number>14</span>, <span class=number>14</span>, <span class=number>14</span>, <span class=number>14</span>, <span class=number>14</span>&#125;,</span><br><span class=line>  &#123;<span class=number>15</span>, <span class=number>15</span>, <span class=number>15</span>, <span class=number>15</span>, <span class=number>15</span>, <span class=number>15</span>&#125;, &#123;<span class=number>16</span>, <span class=number>16</span>, <span class=number>16</span>, <span class=number>16</span>, <span class=number>16</span>, <span class=number>16</span>&#125;, &#123;<span class=number>17</span>, <span class=number>17</span>, <span class=number>17</span>, <span class=number>17</span>, <span class=number>17</span>, <span class=number>17</span>&#125;,</span><br><span class=line>  &#123;<span class=number>18</span>, <span class=number>18</span>, <span class=number>18</span>, <span class=number>18</span>, <span class=number>18</span>, <span class=number>18</span>&#125;, &#123;<span class=number>19</span>, <span class=number>19</span>, <span class=number>19</span>, <span class=number>19</span>, <span class=number>19</span>, <span class=number>19</span>&#125;, &#123;<span class=number>20</span>, <span class=number>20</span>, <span class=number>20</span>, <span class=number>20</span>, <span class=number>20</span>, <span class=number>20</span>&#125;,</span><br><span class=line>  &#123;<span class=number>21</span>, <span class=number>21</span>, <span class=number>21</span>, <span class=number>21</span>, <span class=number>21</span>, <span class=number>21</span>&#125;, &#123;<span class=number>22</span>, <span class=number>22</span>, <span class=number>22</span>, <span class=number>22</span>, <span class=number>22</span>, <span class=number>22</span>&#125;, &#123;<span class=number>23</span>, <span class=number>23</span>, <span class=number>23</span>, <span class=number>23</span>, <span class=number>23</span>, <span class=number>23</span>&#125;,</span><br><span class=line>  &#123;<span class=number>24</span>, <span class=number>24</span>, <span class=number>24</span>, <span class=number>24</span>, <span class=number>24</span>, <span class=number>24</span>&#125;, &#123;<span class=number>25</span>, <span class=number>25</span>, <span class=number>25</span>, <span class=number>25</span>, <span class=number>25</span>, <span class=number>25</span>&#125;, &#123;<span class=number>26</span>, <span class=number>26</span>, <span class=number>26</span>, <span class=number>26</span>, <span class=number>26</span>, <span class=number>26</span>&#125;,</span><br><span class=line>  &#123;<span class=number>27</span>, <span class=number>27</span>, <span class=number>27</span>, <span class=number>27</span>, <span class=number>27</span>, <span class=number>27</span>&#125;, &#123;<span class=number>28</span>, <span class=number>28</span>, <span class=number>28</span>, <span class=number>28</span>, <span class=number>28</span>, <span class=number>28</span>&#125;, &#123;<span class=number>29</span>, <span class=number>29</span>, <span class=number>29</span>, <span class=number>29</span>, <span class=number>29</span>, <span class=number>29</span>&#125;,</span><br><span class=line>  &#123;<span class=number>30</span>, <span class=number>30</span>, <span class=number>30</span>, <span class=number>30</span>, <span class=number>30</span>, <span class=number>30</span>&#125;, &#123;<span class=number>31</span>, <span class=number>31</span>, <span class=number>31</span>, <span class=number>31</span>, <span class=number>31</span>, <span class=number>31</span>&#125;</span><br><span class=line>&#125;;</span><br><span class=line></span><br><span class=line><span class=keyword>static</span> <span class=keyword>const</span> <span class=keyword>unsigned</span> <span class=keyword>int</span> R[][<span class=number>6</span>] = </span><br><span class=line>&#123;</span><br><span class=line>  &#123;<span class=number>0x00000000</span>, <span class=number>0x00000000</span>, <span class=number>0x00000000</span>, <span class=number>0x00000000</span>, <span class=number>0x00000000</span>, <span class=number>0x00000000</span>&#125;,</span><br><span class=line>  &#123;<span class=number>0x0000ffff</span>, <span class=number>0x000000ff</span>, <span class=number>0x0000000f</span>, <span class=number>0x00000003</span>, <span class=number>0x00000001</span>, <span class=number>0x00000001</span>&#125;,</span><br><span class=line>  &#123;<span class=number>0x0000ffff</span>, <span class=number>0x000000ff</span>, <span class=number>0x0000000f</span>, <span class=number>0x00000003</span>, <span class=number>0x00000003</span>, <span class=number>0x00000003</span>&#125;,</span><br><span class=line>  &#123;<span class=number>0x00007fff</span>, <span class=number>0x0000003f</span>, <span class=number>0x00000007</span>, <span class=number>0x00000007</span>, <span class=number>0x00000007</span>, <span class=number>0x00000007</span>&#125;,</span><br><span class=line>  &#123;<span class=number>0x0000ffff</span>, <span class=number>0x000000ff</span>, <span class=number>0x0000000f</span>, <span class=number>0x0000000f</span>, <span class=number>0x0000000f</span>, <span class=number>0x0000000f</span>&#125;,</span><br><span class=line>  &#123;<span class=number>0x00007fff</span>, <span class=number>0x0000001f</span>, <span class=number>0x0000001f</span>, <span class=number>0x0000001f</span>, <span class=number>0x0000001f</span>, <span class=number>0x0000001f</span>&#125;,</span><br><span class=line>  &#123;<span class=number>0x00000fff</span>, <span class=number>0x0000003f</span>, <span class=number>0x0000003f</span>, <span class=number>0x0000003f</span>, <span class=number>0x0000003f</span>, <span class=number>0x0000003f</span>&#125;,</span><br><span class=line>  &#123;<span class=number>0x00003fff</span>, <span class=number>0x0000007f</span>, <span class=number>0x0000007f</span>, <span class=number>0x0000007f</span>, <span class=number>0x0000007f</span>, <span class=number>0x0000007f</span>&#125;,</span><br><span class=line>  &#123;<span class=number>0x0000ffff</span>, <span class=number>0x000000ff</span>, <span class=number>0x000000ff</span>, <span class=number>0x000000ff</span>, <span class=number>0x000000ff</span>, <span class=number>0x000000ff</span>&#125;,</span><br><span class=line>  &#123;<span class=number>0x000001ff</span>, <span class=number>0x000001ff</span>, <span class=number>0x000001ff</span>, <span class=number>0x000001ff</span>, <span class=number>0x000001ff</span>, <span class=number>0x000001ff</span>&#125;, </span><br><span class=line>  &#123;<span class=number>0x000003ff</span>, <span class=number>0x000003ff</span>, <span class=number>0x000003ff</span>, <span class=number>0x000003ff</span>, <span class=number>0x000003ff</span>, <span class=number>0x000003ff</span>&#125;, </span><br><span class=line>  &#123;<span class=number>0x000007ff</span>, <span class=number>0x000007ff</span>, <span class=number>0x000007ff</span>, <span class=number>0x000007ff</span>, <span class=number>0x000007ff</span>, <span class=number>0x000007ff</span>&#125;, </span><br><span class=line>  &#123;<span class=number>0x00000fff</span>, <span class=number>0x00000fff</span>, <span class=number>0x00000fff</span>, <span class=number>0x00000fff</span>, <span class=number>0x00000fff</span>, <span class=number>0x00000fff</span>&#125;, </span><br><span class=line>  &#123;<span class=number>0x00001fff</span>, <span class=number>0x00001fff</span>, <span class=number>0x00001fff</span>, <span class=number>0x00001fff</span>, <span class=number>0x00001fff</span>, <span class=number>0x00001fff</span>&#125;, </span><br><span class=line>  &#123;<span class=number>0x00003fff</span>, <span class=number>0x00003fff</span>, <span class=number>0x00003fff</span>, <span class=number>0x00003fff</span>, <span class=number>0x00003fff</span>, <span class=number>0x00003fff</span>&#125;, </span><br><span class=line>  &#123;<span class=number>0x00007fff</span>, <span class=number>0x00007fff</span>, <span class=number>0x00007fff</span>, <span class=number>0x00007fff</span>, <span class=number>0x00007fff</span>, <span class=number>0x00007fff</span>&#125;, </span><br><span class=line>  &#123;<span class=number>0x0000ffff</span>, <span class=number>0x0000ffff</span>, <span class=number>0x0000ffff</span>, <span class=number>0x0000ffff</span>, <span class=number>0x0000ffff</span>, <span class=number>0x0000ffff</span>&#125;, </span><br><span class=line>  &#123;<span class=number>0x0001ffff</span>, <span class=number>0x0001ffff</span>, <span class=number>0x0001ffff</span>, <span class=number>0x0001ffff</span>, <span class=number>0x0001ffff</span>, <span class=number>0x0001ffff</span>&#125;, </span><br><span class=line>  &#123;<span class=number>0x0003ffff</span>, <span class=number>0x0003ffff</span>, <span class=number>0x0003ffff</span>, <span class=number>0x0003ffff</span>, <span class=number>0x0003ffff</span>, <span class=number>0x0003ffff</span>&#125;, </span><br><span class=line>  &#123;<span class=number>0x0007ffff</span>, <span class=number>0x0007ffff</span>, <span class=number>0x0007ffff</span>, <span class=number>0x0007ffff</span>, <span class=number>0x0007ffff</span>, <span class=number>0x0007ffff</span>&#125;,</span><br><span class=line>  &#123;<span class=number>0x000fffff</span>, <span class=number>0x000fffff</span>, <span class=number>0x000fffff</span>, <span class=number>0x000fffff</span>, <span class=number>0x000fffff</span>, <span class=number>0x000fffff</span>&#125;, </span><br><span class=line>  &#123;<span class=number>0x001fffff</span>, <span class=number>0x001fffff</span>, <span class=number>0x001fffff</span>, <span class=number>0x001fffff</span>, <span class=number>0x001fffff</span>, <span class=number>0x001fffff</span>&#125;, </span><br><span class=line>  &#123;<span class=number>0x003fffff</span>, <span class=number>0x003fffff</span>, <span class=number>0x003fffff</span>, <span class=number>0x003fffff</span>, <span class=number>0x003fffff</span>, <span class=number>0x003fffff</span>&#125;, </span><br><span class=line>  &#123;<span class=number>0x007fffff</span>, <span class=number>0x007fffff</span>, <span class=number>0x007fffff</span>, <span class=number>0x007fffff</span>, <span class=number>0x007fffff</span>, <span class=number>0x007fffff</span>&#125;, </span><br><span class=line>  &#123;<span class=number>0x00ffffff</span>, <span class=number>0x00ffffff</span>, <span class=number>0x00ffffff</span>, <span class=number>0x00ffffff</span>, <span class=number>0x00ffffff</span>, <span class=number>0x00ffffff</span>&#125;,</span><br><span class=line>  &#123;<span class=number>0x01ffffff</span>, <span class=number>0x01ffffff</span>, <span class=number>0x01ffffff</span>, <span class=number>0x01ffffff</span>, <span class=number>0x01ffffff</span>, <span class=number>0x01ffffff</span>&#125;, </span><br><span class=line>  &#123;<span class=number>0x03ffffff</span>, <span class=number>0x03ffffff</span>, <span class=number>0x03ffffff</span>, <span class=number>0x03ffffff</span>, <span class=number>0x03ffffff</span>, <span class=number>0x03ffffff</span>&#125;, </span><br><span class=line>  &#123;<span class=number>0x07ffffff</span>, <span class=number>0x07ffffff</span>, <span class=number>0x07ffffff</span>, <span class=number>0x07ffffff</span>, <span class=number>0x07ffffff</span>, <span class=number>0x07ffffff</span>&#125;,</span><br><span class=line>  &#123;<span class=number>0x0fffffff</span>, <span class=number>0x0fffffff</span>, <span class=number>0x0fffffff</span>, <span class=number>0x0fffffff</span>, <span class=number>0x0fffffff</span>, <span class=number>0x0fffffff</span>&#125;,</span><br><span class=line>  &#123;<span class=number>0x1fffffff</span>, <span class=number>0x1fffffff</span>, <span class=number>0x1fffffff</span>, <span class=number>0x1fffffff</span>, <span class=number>0x1fffffff</span>, <span class=number>0x1fffffff</span>&#125;, </span><br><span class=line>  &#123;<span class=number>0x3fffffff</span>, <span class=number>0x3fffffff</span>, <span class=number>0x3fffffff</span>, <span class=number>0x3fffffff</span>, <span class=number>0x3fffffff</span>, <span class=number>0x3fffffff</span>&#125;, </span><br><span class=line>  &#123;<span class=number>0x7fffffff</span>, <span class=number>0x7fffffff</span>, <span class=number>0x7fffffff</span>, <span class=number>0x7fffffff</span>, <span class=number>0x7fffffff</span>, <span class=number>0x7fffffff</span>&#125;</span><br><span class=line>&#125;;</span><br><span class=line></span><br><span class=line><span class=keyword>unsigned</span> <span class=keyword>int</span> n;       <span class=comment>// numerator</span></span><br><span class=line><span class=keyword>const</span> <span class=keyword>unsigned</span> <span class=keyword>int</span> s; <span class=comment>// s &gt; 0</span></span><br><span class=line><span class=keyword>const</span> <span class=keyword>unsigned</span> <span class=keyword>int</span> d = (<span class=number>1</span> &lt;&lt; s) - <span class=number>1</span>; <span class=comment>// so d is either 1, 3, 7, 15, 31, ...).</span></span><br><span class=line><span class=keyword>unsigned</span> <span class=keyword>int</span> m;       <span class=comment>// n % d goes here.</span></span><br><span class=line></span><br><span class=line>m = (n &amp; M[s]) + ((n &gt;&gt; s) &amp; M[s]);</span><br><span class=line></span><br><span class=line><span class=keyword>for</span> (<span class=keyword>const</span> <span class=keyword>unsigned</span> <span class=keyword>int</span> * q = &amp;Q[s][<span class=number>0</span>], * r = &amp;R[s][<span class=number>0</span>]; m &gt; d; q++, r++)</span><br><span class=line>&#123;</span><br><span class=line>  m = (m &gt;&gt; *q) + (m &amp; *r);</span><br><span class=line>&#125;</span><br><span class=line>m = m == d ? <span class=number>0</span> : m; <span class=comment>// OR, less portably: m = m &amp; -((signed)(m - d) &gt;&gt; s);</span></span><br></pre></td></tr></table></figure><p>该方法求关于 $2^N-1$ 的余数至多需要 $O(\lg N)$ 时间，其中<code>N</code>是被除数位长（以上代码是针对32位的）。所需操作次数至多是 $12 + 9 \lceil \lg N \rceil$. 如果你能在编译器知道除数的话，就能去掉表，只需提取相关条目并做循环展开。该方法很容易能扩展到更长位宽。</p></div></div><div class=license-notice><span>作者:</span>Dr. A. Clef<br><span>发布日期:</span>2015-12-04<br><span>修改日期:</span>2017-06-10<br><span>发布协议:</span> <a href=https://creativecommons.org/licenses/by-sa/4.0 target=_blank>BY-SA</a></div><nav class=post-tags><a href="/tags/算法/" title=算法 rel=tag class="fa fa-tag">算法</a></nav></article></div><!-- div#primary --><ul id=pager><li class=previous><a href=/2015-12-05-Leetcode-26-Remove-Duplicates-from-Sorted-Array.html title="Leetcode 26 Remove Duplicates from Sorted Array" class="tooltipped tooltipped-n" aria-label="Leetcode 26 Remove Duplicates from Sorted Array"><span class="fa fa-chevron-left"></span> 上一篇文章</a></li><li class=next><a href=/2015-12-03-Leetcode-70-Climbing-Stairs.html title="Leetcode 70 Climbing Stairs" class="tooltipped tooltipped-n" aria-label="Leetcode 70 Climbing Stairs">下一篇文章 <span class="fa fa-chevron-right"></span></a></li></ul><section id=comments><!-- disqus start --><div id=disqus_thread class=disqus-thread></div><!-- disqus end --></section><nav id=toc class=sticky><ol class=toc><li class="toc-item toc-level-2"><a class=toc-link href=#开头语><span class=toc-text>开头语</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#关于操作统计的说明><span class=toc-text>关于操作统计的说明</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#获取一个整数的正负号><span class=toc-text>获取一个整数的正负号</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#检测两个整数是否异号><span class=toc-text>检测两个整数是否异号</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#不利用分支来计算整数的绝对值><span class=toc-text>不利用分支来计算整数的绝对值</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#不利用分支来计算两个整数的最大-max-最小-min-值><span class=toc-text>不利用分支来计算两个整数的最大(max)最小(min)值</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#快而脏的解法><span class=toc-text>快而脏的解法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#检测一个数是不是2的次幂><span class=toc-text>检测一个数是不是2的次幂</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#符号扩展><span class=toc-text>符号扩展</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#从给定位宽扩展><span class=toc-text>从给定位宽扩展</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#从不定长位宽扩展><span class=toc-text>从不定长位宽扩展</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#从不定长位宽扩展-3次操作><span class=toc-text>从不定长位宽扩展，3次操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#选择性地置位清零-不利用分支><span class=toc-text>选择性地置位清零，不利用分支</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#选择性地取负-不利用分支><span class=toc-text>选择性地取负，不利用分支</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#根据掩码合并两个数><span class=toc-text>根据掩码合并两个数</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#统计数位中1的个数><span class=toc-text>统计数位中1的个数</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#简单粗暴的解法><span class=toc-text>简单粗暴的解法</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#查表法><span class=toc-text>查表法</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#brian-kernighan的方法><span class=toc-text>Brian Kernighan的方法</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#针对14-24-或32位长数字-使用64位指令集><span class=toc-text>针对14, 24, 或32位长数字，使用64位指令集</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#并行方法><span class=toc-text>并行方法</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#从最高位到指定位><span class=toc-text>从最高位到指定位</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#已知rank求出位数><span class=toc-text>已知rank求出位数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#奇偶校验><span class=toc-text>奇偶校验</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#简单粗暴的解法-v2><span class=toc-text>简单粗暴的解法</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#查表法-v2><span class=toc-text>查表法</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#使用64位指令集的乘法和求余><span class=toc-text>使用64位指令集的乘法和求余</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#使用一次乘法><span class=toc-text>使用一次乘法</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#并行法><span class=toc-text>并行法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#交换两个数的值><span class=toc-text>交换两个数的值</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#使用加减法><span class=toc-text>使用加减法</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#使用异或><span class=toc-text>使用异或</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#交换指定的某几个二进制位><span class=toc-text>交换指定的某几个二进制位</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#倒置二进制位><span class=toc-text>倒置二进制位</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#直接解法><span class=toc-text>直接解法</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#查表法-v3><span class=toc-text>查表法</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#倒置一比特-仅用3次操作-使用64位的乘法和求余><span class=toc-text>倒置一比特，仅用3次操作（使用64位的乘法和求余）</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#倒置一比特-仅用4次操作-使用64位的乘法-不使用除法><span class=toc-text>倒置一比特，仅用4次操作（使用64位的乘法，不使用除法）</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#倒置一比特-仅用7次操作-不使用64位><span class=toc-text>倒置一比特，仅用7次操作（不使用64位）</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#倒置n位-并行法-使用-5-lg-n-次操作><span class=toc-text>倒置N位，并行法，使用 5*lg(N) 次操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#求余除法><span class=toc-text>求余除法</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#不使用除法-计算关于-1-s-的余数><span class=toc-text>不使用除法，计算关于 1&lt;&lt;s 的余数</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#不使用除法-计算关于-1-s-1-的余数><span class=toc-text>不使用除法，计算关于 (1&lt;&lt;s) - 1 的余数</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#不使用除法-并行计算关于-1-s-1-的余数><span class=toc-text>不使用除法，并行计算关于 (1&lt;&lt;s) - 1 的余数</span></a></li></ol></li></ol></nav></div></main><!-- Footer --><!-- #content --><footer id=footer><div class=container><p><span class=cc-license><a href=https://creativecommons.org/licenses/by-sa/4.0 target=_blank title="Creative Commons license by-sa"><span class="cc cc-cc"></span> <span class="cc cc-by"></span> <span class="cc cc-sa"></span></a></span> &nbsp;2015-2018 BUG研发中心.</p><p>Themed by <a href=https://github.com/unnamed42/hexo-theme-kunkka>Kunkka</a> | Powered by <a href="https://hexo.io/">Hexo</a>.</p><div class=sns-icons><span class="sns-icon fa-stack"><a target=_blank href=https://github.com/unnamed42><span class="fa fa-square fa-stack-2x"></span> <span class="fa fa-github fa-stack-1x fa-inverse"></span></a></span> <span class="sns-icon fa-stack"><a target=_blank href=https://plus.google.com/u/0/101538012089625781458><span class="fa fa-square fa-stack-2x"></span> <span class="fa fa-google-plus fa-stack-1x fa-inverse"></span></a></span> <span class="sns-icon fa-stack"><a target=_blank href=https://www.zhihu.com/people/huang-wen-rui-74><span class="fa fa-square fa-stack-2x"></span> <span class="fa fa-stack-1x fa-inverse">知</span></a></span> <span class="sns-icon fa-stack"><a target=_blank href="http://tieba.baidu.com/home/main/?un=Xelnagaman"><span class="fa fa-square fa-stack-2x"></span> <span class="fa fa-stack-1x fa-inverse">贴</span></a></span></div></div></footer><!-- #footer --><div id=totop title=送你上天><canvas id=totop-canvas width=48 height=48></canvas><div id=totop-percent></div></div></body></html>